// SPDX-License-Identifier: LGPL-3.0-or-later

package main

import (
	"context"
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"syscall"
	"time"

	"github.com/charmbracelet/bubbles/help"
	"github.com/charmbracelet/bubbles/key"
	"github.com/charmbracelet/bubbles/progress"
	"github.com/charmbracelet/bubbles/spinner"
	"github.com/charmbracelet/bubbles/textinput"
	tea "github.com/charmbracelet/bubbletea"
	"github.com/charmbracelet/lipgloss"
	"hypersdk/logger"
	"hypersdk/providers/vsphere"
)

// exportTemplate defines an export configuration preset
type exportTemplate struct {
	name        string
	description string
	format      string // "ovf" or "ova"
	compress    bool
	verify      bool
}

// Export templates (same as hyperctl)
var exportTemplates = []exportTemplate{
	{
		name:        "Quick Export",
		description: "Fast export without compression (OVF format)",
		format:      "ovf",
		compress:    false,
		verify:      false,
	},
	{
		name:        "Production Backup",
		description: "OVA with compression and verification",
		format:      "ova",
		compress:    true,
		verify:      true,
	},
	{
		name:        "Development",
		description: "OVF format for fast development cycles",
		format:      "ovf",
		compress:    false,
		verify:      false,
	},
	{
		name:        "Archive",
		description: "Compressed OVA for long-term storage",
		format:      "ova",
		compress:    true,
		verify:      true,
	},
}

// TUI model for interactive hyperexport
// logEntry represents a single log message in the TUI
type logEntry struct {
	timestamp time.Time
	level     string // "INFO", "WARN", "ERROR", "DEBUG"
	message   string
	vmName    string // associated VM if any
}

// folderNode represents a folder in the VM hierarchy tree
type folderNode struct {
	name     string
	path     string
	parent   *folderNode
	children []*folderNode
	vms      []tuiVMItem
	expanded bool
	level    int
}

// exportPreview holds estimated export information
type exportPreview struct {
	vmName            string
	totalSize         int64
	diskCount         int
	fileBreakdown     map[string]int64 // file type -> size
	estimatedDuration time.Duration
	diskSpaceNeeded   int64
	diskSpaceAvail    int64
	files             []previewFile
}

// previewFile represents a file in the export preview
type previewFile struct {
	name     string
	fileType string // "vmdk", "ovf", "mf", "cert"
	size     int64
}

// quickAction represents an action that can be performed on a VM
type quickAction struct {
	name        string
	description string
	icon        string
	category    string // "power", "snapshot", "export", "info"
	handler     func(*tuiModel, *vsphere.VMInfo) (tea.Model, tea.Cmd)
	enabled     func(*vsphere.VMInfo) bool
}

// bulkOperation represents an operation that can be performed on multiple VMs
type bulkOperation struct {
	name        string
	description string
	icon        string
	category    string // "power", "snapshot", "maintenance"
	confirmText string // Confirmation message before executing
	handler     func(*tuiModel, []vsphere.VMInfo) tea.Cmd
	enabled     func([]vsphere.VMInfo) bool
}

// bulkOpStatus tracks the status of a bulk operation on a VM
type bulkOpStatus struct {
	vmName    string
	status    string // "pending", "running", "completed", "failed"
	message   string
	startTime time.Time
	endTime   time.Time
	error     error
}

// vmBookmark represents a saved VM selection
type vmBookmark struct {
	name        string
	description string
	vmPaths     []string // VM paths included in bookmark
	created     time.Time
	icon        string
}

// savedFilter represents a saved filter configuration
type savedFilter struct {
	name        string
	description string
	powerState  string // "on", "off", ""
	osFilter    string
	minCPU      int32
	minMemoryGB float64
	minStorageGB float64
	searchQuery string
	created     time.Time
}

// filterBuilderState manages the interactive filter builder
type filterBuilderState struct {
	focusedField     int
	namePattern      string
	powerState       string // "", "on", "off"
	osPattern        string
	minCPU           int32
	maxCPU           int32
	minMemoryGB      float64
	maxMemoryGB      float64
	minStorageGB     float64
	maxStorageGB     float64
	tagsPattern      string
	folderPattern    string
	matchMode        string // "all" (AND), "any" (OR)
	caseSensitive    bool
	useRegex         bool
	previewResults   []vsphere.VMInfo
	filterName       string
	filterDesc       string
	mode             string // "build", "save", "preview"
}

// filterBuilderField represents a single field in the filter builder
type filterBuilderField struct {
	name        string
	value       string
	description string
	fieldType   string // "text", "number", "bool", "choice"
	choices     []string
}

// vmSnapshot represents a VM snapshot
type vmSnapshot struct {
	id          string
	name        string
	description string
	created     time.Time
	size        int64
	state       string // "poweredOn", "poweredOff"
	parent      string // parent snapshot ID
	children    []string // child snapshot IDs
	isCurrent   bool
}

// snapshotManagerState manages the snapshot interface
type snapshotManagerState struct {
	vm              *vsphere.VMInfo
	snapshots       []vmSnapshot
	cursor          int
	mode            string // "list", "create", "details", "tree"
	selectedSnap    *vmSnapshot
	createName      string
	createDesc      string
	createMemory    bool
	createQuiesce   bool
	treeView        []snapshotTreeNode
	treeCursor      int
}

// snapshotTreeNode represents a node in the snapshot tree
type snapshotTreeNode struct {
	snapshot *vmSnapshot
	level    int
	isLast   bool
	expanded bool
}

// resourceAllocation represents a resource allocation scenario
type resourceAllocation struct {
	name             string
	description      string
	targetHost       string
	vms              []vsphere.VMInfo
	totalCPU         int32
	totalMemory      int64
	totalStorage     int64
	cpuUtilization   float64
	memoryUtilization float64
	storageUtilization float64
	warnings         []string
	recommendations  []string
}

// resourcePlannerState manages the resource allocation planner
type resourcePlannerState struct {
	mode            string // "overview", "hosts", "plan", "optimize", "recommendations"
	scenarios       []resourceAllocation
	selectedScenario int
	cursor          int
	hostCapacity    map[string]hostResources
	optimizationGoal string // "balanced", "cpu", "memory", "storage", "cost"
}

// hostResources represents available resources on a host
type hostResources struct {
	name            string
	totalCPU        int32
	totalMemory     int64
	totalStorage    int64
	availableCPU    int32
	availableMemory int64
	availableStorage int64
	vmCount         int
	status          string // "healthy", "overcommitted", "underutilized"
}

// migrationWizardState manages the migration wizard workflow
type migrationWizardState struct {
	step             int    // Current step in wizard (0-6)
	vms              []vsphere.VMInfo
	sourceType       string // "vsphere", "aws", "azure", "hyperv"
	targetType       string // "vsphere", "aws", "azure", "kvm", "local"
	sourceDetails    map[string]string
	targetDetails    map[string]string
	migrationMode    string // "cold", "hot", "snapshot"
	validationChecks []migrationCheck
	warnings         []string
	readyToMigrate   bool
	estimatedTime    time.Duration
	estimatedSize    int64
	networkBandwidth int64 // bytes per second
	scheduledTime    time.Time
	useSchedule      bool
}

// migrationCheck represents a pre-migration validation check
type migrationCheck struct {
	name     string
	status   string // "pending", "running", "passed", "failed", "warning"
	message  string
	critical bool // If true, migration cannot proceed if failed
}

// migrationStep represents a step in the wizard
type migrationStep struct {
	number      int
	title       string
	description string
	completed   bool
}

type tuiModel struct{
	vms              []tuiVMItem
	filteredVMs      []tuiVMItem
	cursor           int
	phase            string // "select", "confirm", "template", "regex", "cloud", "features", "export", "cloudupload", "done", "search", "details", "validation", "config", "stats", "queue", "history", "logs", "tree", "preview", "actions", "bulkops", "compare", "bookmarks", "metrics", "filterbuilder", "snapshots", "resources", "migration"
	detailsVM        *vsphere.VMInfo // VM to show details for
	validationReport *ValidationReport // Pre-export validation results
	configPanel      *configPanelState // Interactive config panel state
	searchQuery      string
	sortMode         string // "name", "cpu", "memory", "storage", "power"
	filterPower      string // "", "on", "off"
	filterOS         string
	quickFilter      string
	showHelp         bool
	regexPattern     string
	selectedTemplate *exportTemplate
	message          string
	err              error

	// Export state
	currentExport   int
	exportProgress  exportProgressState
	currentVMName   string
	currentFileName string

	// Cloud configuration
	cloudConfig       *cloudConfig
	enableCloudUpload bool

	// Advanced Features Configuration
	featureConfig featureConfiguration

	// Modern UI components
	progressBar progress.Model
	helpModel   help.Model
	spinner     spinner.Model
	searchInput textinput.Model
	keys        tuiKeyMap

	// Terminal size
	termWidth  int
	termHeight int

	// Animation frame counter
	animFrame int

	// Split-screen mode
	splitScreenMode bool
	focusedPane     string // "list" or "details"

	// Export queue management
	exportQueue     []queuedExport
	queueCursor     int
	showQueueEditor bool

	// Export history view
	historyEntries       []ExportHistoryEntry
	historyCursor        int
	historyFilter        string // "all", "success", "failed"
	historySearchQuery   string
	historyDateFilter    string // "all", "today", "week", "month"
	historyProviderFilter string // "all", "vsphere", etc.

	// Live logs viewer
	logEntries      []logEntry
	logCursor       int
	logLevelFilter  string // "all", "info", "warn", "error", "debug"
	logSearchQuery  string
	autoScrollLogs  bool
	showLogsPanel   bool
	maxLogEntries   int

	// Folder tree view
	folderTree      *folderNode
	viewMode        string // "list" or "tree"
	treeItems       []interface{} // flattened tree for rendering (mix of *folderNode and tuiVMItem)
	treeCursor      int

	// Export preview
	exportPreviews  []exportPreview
	previewCursor   int
	showPreview     bool

	// Quick actions menu
	showActionsMenu bool
	actionsCursor   int
	actionsForVM    *vsphere.VMInfo

	// Bulk operations manager
	showBulkOps     bool
	bulkOpsCursor   int
	bulkOpsProgress map[string]bulkOpStatus // VM path -> status

	// VM comparison view
	showComparison   bool
	comparisonVMs    []vsphere.VMInfo
	comparisonScroll int
	comparisonMode   string // "overview", "resources", "storage", "network"

	// Saved filters and bookmarks
	showBookmarks    bool
	bookmarks        []vmBookmark
	bookmarkCursor   int
	savedFilters     []savedFilter
	filtersCursor    int

	// Performance metrics dashboard
	showMetrics      bool
	metricsMode      string // "overview", "cpu", "memory", "storage"
	metricsRefresh   time.Time

	// Advanced filter builder
	showFilterBuilder bool
	filterBuilder     *filterBuilderState
	filterPreviewCount int

	// Snapshot manager
	showSnapshotManager bool
	snapshotManager     *snapshotManagerState

	// Resource allocation planner
	showResourcePlanner bool
	resourcePlanner     *resourcePlannerState

	// Migration wizard
	showMigrationWizard bool
	migrationWizard     *migrationWizardState

	// Configuration
	client       *vsphere.VSphereClient
	outputDir    string
	log          logger.Logger
	ctx          context.Context
	cancelExport context.CancelFunc // Function to cancel ongoing export
}

// queuedExport represents a VM in the export queue
type queuedExport struct {
	vm       vsphere.VMInfo
	priority int    // 1=high, 2=normal, 3=low
	status   string // "pending", "running", "completed", "failed"
	eta      time.Duration
	startedAt time.Time
	error    error
}

// featureConfiguration holds advanced export features
type featureConfiguration struct {
	// Snapshot settings
	enableSnapshot     bool
	snapshotMemory     bool
	snapshotQuiesce    bool
	deleteSnapshot     bool
	keepSnapshots      int
	consolidateSnaps   bool

	// Bandwidth settings
	enableBandwidthLimit bool
	bandwidthLimitMBps   int64
	adaptiveBandwidth    bool

	// Incremental export settings
	enableIncremental bool
	showIncrementalInfo bool

	// Email notifications
	enableEmail       bool
	emailSMTPHost     string
	emailSMTPPort     int
	emailFrom         string
	emailTo           string
	emailOnStart      bool
	emailOnComplete   bool
	emailOnFailure    bool

	// Cleanup settings
	enableCleanup   bool
	cleanupMaxAge   int // days
	cleanupMaxCount int
	cleanupDryRun   bool
}

type tuiVMItem struct {
	vm       vsphere.VMInfo
	selected bool
}

type exportProgressState struct {
	currentBytes   int64
	totalBytes     int64
	currentFileIdx int
	totalFiles     int
	speed          float64 // MB/s
	startTime      time.Time
	lastUpdateTime time.Time
	lastBytes      int64
}

// configPanelState manages interactive configuration editing
type configPanelState struct {
	focusedField int
	fields       []configField
	isDirty      bool
}

// configField represents a single configurable field
type configField struct {
	label       string
	key         string
	value       string
	inputModel  textinput.Model
	fieldType   string // "text", "number", "bool", "select"
	options     []string // for select fields
	description string
	validator   func(string) error
}

// Modern key bindings
type tuiKeyMap struct {
	Up          key.Binding
	Down        key.Binding
	Select      key.Binding
	Confirm     key.Binding
	Back        key.Binding
	Quit        key.Binding
	Help        key.Binding
	Filter      key.Binding
	Sort        key.Binding
	Features    key.Binding
	Cloud       key.Binding
	SplitScreen key.Binding
	SwitchPane  key.Binding
	Queue       key.Binding
	MoveUp      key.Binding
	MoveDown    key.Binding
	Priority    key.Binding
	History     key.Binding
	FilterHistory key.Binding
	Logs        key.Binding
	FilterLogs  key.Binding
	ToggleAutoScroll key.Binding
	Tree        key.Binding
	ExpandFolder key.Binding
	Preview     key.Binding
	Actions     key.Binding
	BulkOps     key.Binding
	Compare     key.Binding
	Bookmarks   key.Binding
	Metrics     key.Binding
	FilterBuilder key.Binding
	Snapshots   key.Binding
	Resources   key.Binding
	Migration   key.Binding
}

func (k tuiKeyMap) ShortHelp() []key.Binding {
	return []key.Binding{k.Help, k.Quit}
}

func (k tuiKeyMap) FullHelp() [][]key.Binding {
	return [][]key.Binding{
		{k.Up, k.Down, k.Select, k.Confirm},
		{k.Filter, k.Sort, k.Features, k.Cloud},
		{k.Back, k.Help, k.Quit},
	}
}

// Modern color palette inspired by Tokyo Night / Catppuccin aesthetic
var (
	// Core palette - vibrant, modern colors for terminal UIs
	deepOrange    = lipgloss.Color("#FF9E64") // Vibrant peach/orange (primary accent)
	tealInfo      = lipgloss.Color("#7DCFFF") // Bright cyan (info/directories)
	successGreen  = lipgloss.Color("#9ECE6A") // Fresh lime green (success)
	warmRed       = lipgloss.Color("#F7768E") // Soft red (errors)
	amberYellow   = lipgloss.Color("#E0AF68") // Golden amber (warnings)
	offWhite      = lipgloss.Color("#C0CAF5") // Light lavender-white (text)
	darkCharcoal  = lipgloss.Color("#1A1B26") // Tokyo Night dark background
	lightCharcoal = lipgloss.Color("#24283B") // Slightly lighter background
	mutedGray     = lipgloss.Color("#565F89") // Muted blue-gray

	// Semantic color mappings.
	primaryColor   = deepOrange    // Orange as signal
	secondaryColor = tealInfo      // Teal for information
	successColor   = successGreen  // Green for success
	warningColor   = amberYellow   // Amber for warnings
	errorColor     = warmRed       // Red for errors
	mutedColor     = mutedGray     // Gray for muted text
	highlightColor = deepOrange    // Orange highlights
	textColor      = offWhite      // Default text
	darkBg         = darkCharcoal  // Primary background
	lightBg        = lightCharcoal // Secondary background

	// Enhanced title with warm orange accent.
	titleStyleTUI = lipgloss.NewStyle().
			Bold(true).
			Foreground(deepOrange).
			Background(darkBg).
			Padding(0, 2).
			Border(lipgloss.RoundedBorder()).
			BorderForeground(tealInfo)

	// Warm selection style.
	selectedStyleTUI = lipgloss.NewStyle().
				Bold(true).
				Foreground(deepOrange).
				Background(lightBg)

	unselectedStyleTUI = lipgloss.NewStyle().
				Foreground(mutedColor)

	infoStyleTUI = lipgloss.NewStyle().
			Foreground(tealInfo).
			Italic(true)

	helpStyleTUI = lipgloss.NewStyle().
			Foreground(mutedColor).
			Italic(true)

	errorStyleTUI = lipgloss.NewStyle().
			Bold(true).
			Foreground(errorColor)

	successStyleTUI = lipgloss.NewStyle().
			Bold(true).
			Foreground(successColor)

	statsStyleTUI = lipgloss.NewStyle().
			Foreground(secondaryColor).
			Bold(true)

	panelStyleTUI = lipgloss.NewStyle().
			Border(lipgloss.RoundedBorder()).
			BorderForeground(primaryColor).
			Padding(1, 2).
			Margin(1, 0)

	badgeSuccessStyleTUI = lipgloss.NewStyle().
				Background(successColor).
				Foreground(lipgloss.Color("#000000")).
				Padding(0, 1).
				Bold(true)

	badgeWarningStyleTUI = lipgloss.NewStyle().
				Background(warningColor).
				Foreground(lipgloss.Color("#000000")).
				Padding(0, 1).
				Bold(true)

	progressBarStyleTUI = lipgloss.NewStyle().
				Foreground(successColor).
				Background(mutedColor)

	progressLabelStyleTUI = lipgloss.NewStyle().
				Foreground(primaryColor).
				Bold(true)

	keyStyleTUI = lipgloss.NewStyle().
			Foreground(highlightColor).
			Bold(true)

	keyDescStyleTUI = lipgloss.NewStyle().
			Foreground(mutedColor)

	// Enhanced progress bar with gradient colors
	progressFilledStyleTUI = lipgloss.NewStyle().
				Foreground(primaryColor).
				Bold(true)

	progressEmptyStyleTUI = lipgloss.NewStyle().
				Foreground(mutedColor)

	// Animated spinner styles for different contexts
	spinnerStyleTUI = lipgloss.NewStyle().
			Foreground(primaryColor).
			Bold(true)

	spinnerLoadingStyleTUI = lipgloss.NewStyle().
				Foreground(tealInfo)

	spinnerProcessingStyleTUI = lipgloss.NewStyle().
					Foreground(amberYellow)
)

// getSpinnerFrames returns animated spinner frames
func getSpinnerFrames() []string {
	return []string{
		"‚†ã", "‚†ô", "‚†π", "‚†∏", "‚†º", "‚†¥", "‚†¶", "‚†ß", "‚†á", "‚†è",
	}
}

// getDotSpinnerFrames returns dot-based spinner frames
func getDotSpinnerFrames() []string {
	return []string{
		"‚£æ", "‚£Ω", "‚£ª", "‚¢ø", "‚°ø", "‚£ü", "‚£Ø", "‚£∑",
	}
}

// getProgressSpinnerFrames returns progress-style spinner frames
func getProgressSpinnerFrames() []string {
	return []string{
		"‚óê", "‚óì", "‚óë", "‚óí",
	}
}

// renderAnimatedProgressBar renders a smooth gradient progress bar
func renderAnimatedProgressBar(percent float64, width int) string {
	if width < 4 {
		return ""
	}

	filled := int(float64(width) * (percent / 100.0))
	if filled > width {
		filled = width
	}

	// Build progress bar with gradient effect
	var bar strings.Builder

	// Filled portion with gradient
	for i := 0; i < filled; i++ {
		if i < filled-1 {
			bar.WriteString(progressFilledStyleTUI.Render("‚ñà"))
		} else {
			// Last character with gradient
			bar.WriteString(progressFilledStyleTUI.Render("‚ñì"))
		}
	}

	// Empty portion
	for i := filled; i < width; i++ {
		bar.WriteString(progressEmptyStyleTUI.Render("‚ñë"))
	}

	return bar.String()
}

// renderPulsingDot returns a pulsing dot for loading states
func renderPulsingDot(frame int) string {
	dots := []string{"‚ö¨", "‚ö¨", "‚ö¨", "‚¶ø", "‚¶ø", "‚¶ø"}
	idx := frame % len(dots)
	if idx < 3 {
		return spinnerLoadingStyleTUI.Render(dots[idx])
	}
	return spinnerProcessingStyleTUI.Render(dots[idx])
}

type vmsLoadedMsg struct {
	vms []vsphere.VMInfo
	err error
}

type exportDoneMsg struct {
	vmName string
	err    error
}

type tickMsg time.Time

type exportProgressMsg struct {
	vmName         string
	currentBytes   int64
	totalBytes     int64
	currentFileIdx int
	totalFiles     int
	fileName       string
	progressChan   <-chan exportProgressMsg // For recursive listening
	doneChan       <-chan exportDoneMsg     // For completion
}

type validationCompleteMsg struct {
	report *ValidationReport
	err    error
}

type exportStartMsg struct {
	cancelFunc   context.CancelFunc
	exportCmd    tea.Cmd // The actual export command to run after setting cancel
}

func tickCmd() tea.Cmd {
	return tea.Tick(time.Millisecond*100, func(t time.Time) tea.Msg {
		return tickMsg(t)
	})
}

func (m tuiModel) Init() tea.Cmd {
	return tea.Batch(m.loadVMs, m.spinner.Tick, tickCmd())
}

func (m tuiModel) loadVMs() tea.Msg {
	defer func() {
		if r := recover(); r != nil {
			m.log.Error("loadVMs panic", "panic", r)
		}
	}()
	vms, err := m.client.ListVMs(m.ctx)
	if err != nil {
		return vmsLoadedMsg{err: err}
	}
	m.log.Info("VMs loaded successfully", "count", len(vms))
	return vmsLoadedMsg{vms: vms}
}

func (m tuiModel) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	switch msg := msg.(type) {
	case vmsLoadedMsg:
		if msg.err != nil {
			m.err = msg.err
			m.phase = "error"
			return m, tea.Quit
		}

		m.log.Info("Processing loaded VMs", "count", len(msg.vms))
		m.vms = make([]tuiVMItem, len(msg.vms))
		for i, vm := range msg.vms {
			m.vms[i] = tuiVMItem{vm: vm, selected: false}
		}
		m.phase = "select"
		m.log.Info("Applying filters and sorting")
		m.applyFiltersAndSort()
		m.log.Info("Filters applied, entering select phase")
		return m, nil

	case tea.WindowSizeMsg:
		// Update terminal size and adjust UI components
		m.termWidth = msg.Width
		m.termHeight = msg.Height

		// Update progress bar width to fit terminal
		if msg.Width > 20 {
			m.progressBar.Width = min(msg.Width-10, 70)
		}

		// Update help model width
		m.helpModel.Width = msg.Width

		return m, nil

	case tea.KeyMsg:
		switch m.phase {
		case "select":
			return m.handleSelectionKeys(msg)
		case "confirm":
			return m.handleConfirmKeys(msg)
		case "regex":
			return m.handleRegexKeys(msg)
		case "template":
			return m.handleTemplateKeys(msg)
		case "features":
			return m.handleFeaturesKeys(msg)
		case "search":
			return m.handleSearchKeys(msg)
		case "details":
			return m.handleDetailsKeys(msg)
		case "validation":
			return m.handleValidationKeys(msg)
		case "config":
			return m.handleConfigPanelKeys(msg)
		case "stats":
			return m.handleStatsKeys(msg)
		case "queue":
			return m.handleQueueKeys(msg)
		case "history":
			return m.handleHistoryKeys(msg)
		case "logs":
			return m.handleLogsKeys(msg)
		case "tree":
			return m.handleTreeKeys(msg)
		case "preview":
			return m.handlePreviewKeys(msg)
		case "actions":
			return m.handleActionsKeys(msg)
		case "bulkops":
			return m.handleBulkOpsKeys(msg)
		case "compare":
			return m.handleCompareKeys(msg)
		case "bookmarks":
			return m.handleBookmarksKeys(msg)
		case "metrics":
			return m.handleMetricsKeys(msg)
		case "filterbuilder":
			return m.handleFilterBuilderKeys(msg)
		case "snapshots":
			return m.handleSnapshotManagerKeys(msg)
		case "resources":
			return m.handleResourcePlannerKeys(msg)
		case "migration":
			return m.handleMigrationWizardKeys(msg)
		case "export":
			return m.handleExportKeys(msg)
		case "cloud":
			// Cloud phase is handled by cloudSelectionModel
			return m, nil
		}

	case cloudConfigCompleteMsg:
		m.cloudConfig = msg.config
		m.enableCloudUpload = true
		m.phase = "confirm"
		return m, nil

	case exportStartMsg:
		// Store the cancel function and start the export
		m.cancelExport = msg.cancelFunc
		return m, msg.exportCmd

	case exportDoneMsg:
		// Clear cancel function
		m.cancelExport = nil

		if msg.err != nil {
			m.err = msg.err
			return m, tea.Quit
		}
		m.currentExport++
		selectedCount := m.countSelected()
		if m.currentExport >= selectedCount {
			m.phase = "done"
			return m, tea.Quit
		}
		return m, m.exportNext()

	case exportProgressMsg:
		// Update progress state
		m.currentVMName = msg.vmName
		m.currentFileName = msg.fileName
		m.exportProgress.currentBytes = msg.currentBytes
		m.exportProgress.totalBytes = msg.totalBytes
		m.exportProgress.currentFileIdx = msg.currentFileIdx
		m.exportProgress.totalFiles = msg.totalFiles

		// Calculate speed
		now := time.Now()
		if !m.exportProgress.lastUpdateTime.IsZero() {
			elapsed := now.Sub(m.exportProgress.lastUpdateTime).Seconds()
			if elapsed > 0 {
				bytesDiff := msg.currentBytes - m.exportProgress.lastBytes
				m.exportProgress.speed = float64(bytesDiff) / elapsed / (1024 * 1024) // MB/s
			}
		}
		m.exportProgress.lastUpdateTime = now
		m.exportProgress.lastBytes = msg.currentBytes

		// Continue listening for more progress updates
		if msg.progressChan != nil && msg.doneChan != nil {
			return m, func() tea.Msg {
				return m.waitForExport(msg.progressChan, msg.doneChan)
			}
		}

		return m, nil

	case tickMsg:
		// Increment animation frame for spinners and animations
		m.animFrame++

		if m.phase == "export" || m.phase == "validation" || m.phase == "cloudupload" {
			// Continue ticking during animated phases
			return m, tickCmd()
		}
		return m, nil

	case spinner.TickMsg:
		var cmd tea.Cmd
		m.spinner, cmd = m.spinner.Update(msg)
		return m, cmd

	case validationCompleteMsg:
		if msg.err != nil {
			m.err = msg.err
			m.phase = "error"
			return m, nil
		}
		m.validationReport = msg.report
		// Validation display is already shown, just update the model
		return m, nil
	}

	return m, nil
}

func (m tuiModel) handleSelectionKeys(msg tea.KeyMsg) (tea.Model, tea.Cmd) {
	vms := m.getVisibleVMs()

	// Clamp cursor to valid range
	if m.cursor >= len(vms) && len(vms) > 0 {
		m.cursor = len(vms) - 1
	}
	if m.cursor < 0 {
		m.cursor = 0
	}

	switch msg.String() {
	case "ctrl+c", "q":
		return m, tea.Quit

	case "up", "k":
		if m.cursor > 0 {
			m.cursor--
		}

	case "down", "j":
		if m.cursor < len(vms)-1 {
			m.cursor++
		}

	case " ":
		if m.cursor < len(vms) {
			selectedVM := vms[m.cursor]
			for i := range m.vms {
				if m.vms[i].vm.Path == selectedVM.vm.Path {
					m.vms[i].selected = !m.vms[i].selected
					break
				}
			}
		}

	case "a":
		// Select all visible
		visiblePaths := make(map[string]bool)
		for _, vm := range m.getVisibleVMs() {
			visiblePaths[vm.vm.Path] = true
		}
		for i := range m.vms {
			if visiblePaths[m.vms[i].vm.Path] {
				m.vms[i].selected = true
			}
		}

	case "n":
		// Deselect all visible
		visiblePaths := make(map[string]bool)
		for _, vm := range m.getVisibleVMs() {
			visiblePaths[vm.vm.Path] = true
		}
		for i := range m.vms {
			if visiblePaths[m.vms[i].vm.Path] {
				m.vms[i].selected = false
			}
		}

	case "A":
		// Regex selection
		m.phase = "regex"
		m.regexPattern = ""
		return m, nil

	case "t", "T":
		// Template selection
		m.phase = "template"
		m.cursor = 0
		return m, nil

	case "1", "2", "3", "4", "5", "6", "7", "0":
		m.applyQuickFilter(msg.String())
		return m, nil

	case "/":
		m.phase = "search"
		m.searchInput.Reset()
		m.searchInput.Focus()
		m.searchInput.Placeholder = "Type to search VMs..."
		return m, textinput.Blink

	case "s":
		m.cycleSortMode()
		m.applyFiltersAndSort()
		return m, nil

	case "D":
		// Show statistics dashboard
		m.phase = "stats"
		return m, nil

	case "Q":
		// Show export queue manager
		if m.countSelected() == 0 {
			m.message = "No VMs selected!"
			return m, nil
		}
		// Build queue from selected VMs
		m.exportQueue = m.buildExportQueue()
		m.queueCursor = 0
		m.showQueueEditor = true
		m.phase = "queue"
		return m, nil

	case "H":
		// Show export history
		m.phase = "history"
		m.historyCursor = 0
		m.historyFilter = "all"
		m.historyDateFilter = "all"
		m.historySearchQuery = ""
		m.historyProviderFilter = "all"
		// Load history entries
		if err := m.loadHistoryEntries(); err != nil {
			m.message = fmt.Sprintf("Failed to load history: %v", err)
		}
		return m, nil

	case "L":
		// Show live logs viewer
		m.phase = "logs"
		m.logCursor = 0
		m.logLevelFilter = "all"
		m.logSearchQuery = ""
		// Add some sample logs if empty (for demo)
		if len(m.logEntries) == 0 {
			m.addLogEntry("INFO", "Logs viewer opened", "")
			m.addLogEntry("INFO", "Ready to display export logs", "")
		}
		return m, nil

	case "]":
		// Show folder tree view
		m.viewMode = "tree"
		m.phase = "tree"
		m.treeCursor = 0
		m.buildFolderTree()
		return m, nil

	case "c":
		m.searchQuery = ""
		m.filterPower = ""
		m.filterOS = ""
		m.quickFilter = ""
		m.applyFiltersAndSort()
		m.message = "Filters cleared"
		return m, nil

	case "h", "?":
		m.showHelp = !m.showHelp
		return m, nil

	case "enter":
		if m.countSelected() == 0 {
			m.message = "No VMs selected!"
			return m, nil
		}
		m.phase = "confirm"
		return m, nil

	case "u", "U":
		// Cloud upload configuration
		if m.countSelected() == 0 {
			m.message = "No VMs selected!"
			return m, nil
		}
		m.phase = "cloud"
		cloudModel := newCloudSelectionModel(&m)
		return cloudModel, nil

	case "v", "V":
		// Toggle split screen mode
		m.splitScreenMode = !m.splitScreenMode
		m.focusedPane = "list"
		return m, nil

	case "tab":
		// Switch pane in split screen mode
		if m.splitScreenMode {
			if m.focusedPane == "list" {
				m.focusedPane = "details"
			} else {
				m.focusedPane = "list"
			}
		}
		return m, nil

	case "f", "F":
		// Advanced features configuration
		m.phase = "features"
		m.cursor = 0
		return m, nil

	case "i", "I":
		// Show VM details
		vms := m.getVisibleVMs()
		if m.cursor < len(vms) {
			m.detailsVM = &vms[m.cursor].vm
			m.phase = "details"
		}
		return m, nil

	case "x", "X":
		// Show quick actions menu
		vms := m.getVisibleVMs()
		if m.cursor < len(vms) {
			m.actionsForVM = &vms[m.cursor].vm
			m.actionsCursor = 0
			m.showActionsMenu = true
			m.phase = "actions"
		}
		return m, nil

	case "b", "B":
		// Show bulk operations menu
		if m.countSelected() == 0 {
			m.message = "No VMs selected! Select VMs with SPACE first."
			return m, nil
		}
		m.bulkOpsCursor = 0
		m.showBulkOps = true
		m.bulkOpsProgress = make(map[string]bulkOpStatus)
		m.phase = "bulkops"
		return m, nil

	case "C":
		// Show VM comparison view
		selectedCount := m.countSelected()
		if selectedCount < 2 {
			m.message = "Select at least 2 VMs to compare (use SPACE)"
			return m, nil
		}
		if selectedCount > 4 {
			m.message = "Cannot compare more than 4 VMs at once"
			return m, nil
		}
		// Build comparison list
		m.comparisonVMs = make([]vsphere.VMInfo, 0)
		for _, item := range m.vms {
			if item.selected {
				m.comparisonVMs = append(m.comparisonVMs, item.vm)
			}
		}
		m.showComparison = true
		m.comparisonScroll = 0
		m.comparisonMode = "overview"
		m.phase = "compare"
		return m, nil

	case "m":
		// Show bookmarks and saved filters
		m.showBookmarks = true
		m.bookmarkCursor = 0
		m.phase = "bookmarks"
		// Initialize with sample bookmarks if empty
		if len(m.bookmarks) == 0 {
			m.initializeSampleBookmarks()
		}
		if len(m.savedFilters) == 0 {
			m.initializeSampleFilters()
		}
		return m, nil

	case "M":
		// Show performance metrics dashboard
		m.showMetrics = true
		m.metricsMode = "overview"
		m.metricsRefresh = time.Now()
		m.phase = "metrics"
		return m, nil

	case "G":
		// Show advanced filter builder
		m.showFilterBuilder = true
		m.filterBuilder = &filterBuilderState{
			mode:      "build",
			matchMode: "all",
		}
		m.filterPreviewCount = len(m.vms)
		m.phase = "filterbuilder"
		return m, nil

	case "S":
		// Show snapshot manager for current VM
		vms := m.getVisibleVMs()
		if m.cursor < len(vms) {
			vm := &vms[m.cursor].vm
			m.showSnapshotManager = true
			m.snapshotManager = &snapshotManagerState{
				vm:        vm,
				snapshots: m.loadSnapshotsForVM(vm),
				cursor:    0,
				mode:      "list",
			}
			m.phase = "snapshots"
		}
		return m, nil

	case "R":
		// Show resource allocation planner
		m.showResourcePlanner = true
		m.resourcePlanner = m.initializeResourcePlanner()
		m.phase = "resources"
		return m, nil

	case "W":
		// Show migration wizard
		m.showMigrationWizard = true
		m.migrationWizard = m.initializeMigrationWizard()
		m.phase = "migration"
		return m, nil
	}

	return m, nil
}

func (m tuiModel) handleConfirmKeys(msg tea.KeyMsg) (tea.Model, tea.Cmd) {
	switch msg.String() {
	case "ctrl+c", "q":
		return m, tea.Quit
	case "escape", "n":
		m.phase = "select"
		return m, nil
	case "y", "Y", "enter":
		// Run validation first
		m.phase = "validation"
		return m, m.runValidation()

	case "v", "V":
		// Show validation without starting export
		m.phase = "validation"
		return m, m.runValidation()
	case "u", "U":
		// Configure cloud upload from confirm screen
		m.phase = "cloud"
		cloudModel := newCloudSelectionModel(&m)
		return cloudModel, nil
	case "f", "F":
		// Configure advanced features from confirm screen
		m.phase = "features"
		m.cursor = 0
		return m, nil
	case "c", "C":
		// Open interactive configuration panel
		m.phase = "config"
		m.configPanel = m.newConfigPanel()
		return m, nil
	case "p", "P":
		// Show export preview
		m.phase = "preview"
		m.previewCursor = 0
		m.showPreview = true
		// Generate preview data for selected VMs
		m.exportPreviews = m.generateExportPreviews()
		return m, nil
	}
	return m, nil
}

func (m tuiModel) handleRegexKeys(msg tea.KeyMsg) (tea.Model, tea.Cmd) {
	switch msg.String() {
	case "ctrl+c", "q":
		return m, tea.Quit
	case "escape":
		m.phase = "select"
		m.regexPattern = ""
		return m, nil
	case "enter":
		if m.regexPattern == "" {
			m.message = "Pattern cannot be empty"
			return m, nil
		}
		matches := 0
		for i := range m.vms {
			if matchVMPattern(m.vms[i].vm.Name, m.regexPattern) {
				m.vms[i].selected = true
				matches++
			}
		}
		m.phase = "select"
		m.message = fmt.Sprintf("‚úì Selected %d VMs matching: %s", matches, m.regexPattern)
		m.regexPattern = ""
		return m, nil
	case "backspace", "delete":
		if len(m.regexPattern) > 0 {
			m.regexPattern = m.regexPattern[:len(m.regexPattern)-1]
		}
	default:
		if len(msg.String()) == 1 {
			m.regexPattern += msg.String()
		}
	}
	return m, nil
}

func (m tuiModel) handleTemplateKeys(msg tea.KeyMsg) (tea.Model, tea.Cmd) {
	switch msg.String() {
	case "ctrl+c", "q":
		return m, tea.Quit
	case "escape":
		m.phase = "select"
		return m, nil
	case "up", "k":
		if m.cursor > 0 {
			m.cursor--
		}
	case "down", "j":
		if m.cursor < len(exportTemplates)-1 {
			m.cursor++
		}
	case "enter", "1", "2", "3", "4":
		idx := m.cursor
		if msg.String() >= "1" && msg.String() <= "4" {
			idx = int(msg.String()[0] - '1')
		}
		if idx >= 0 && idx < len(exportTemplates) {
			m.selectedTemplate = &exportTemplates[idx]
			m.phase = "select"
			m.message = fmt.Sprintf("‚úì Template: %s", exportTemplates[idx].name)
		}
		return m, nil
	}
	return m, nil
}

func (m tuiModel) handleFeaturesKeys(msg tea.KeyMsg) (tea.Model, tea.Cmd) {
	maxItems := 14 // Total number of feature options

	switch msg.String() {
	case "ctrl+c", "q":
		return m, tea.Quit
	case "escape":
		m.phase = "select"
		return m, nil
	case "up", "k":
		if m.cursor > 0 {
			m.cursor--
		}
	case "down", "j":
		if m.cursor < maxItems-1 {
			m.cursor++
		}
	case " ", "enter":
		// Toggle the feature at cursor position
		switch m.cursor {
		case 0:
			m.featureConfig.enableSnapshot = !m.featureConfig.enableSnapshot
		case 1:
			m.featureConfig.snapshotMemory = !m.featureConfig.snapshotMemory
		case 2:
			m.featureConfig.snapshotQuiesce = !m.featureConfig.snapshotQuiesce
		case 3:
			m.featureConfig.deleteSnapshot = !m.featureConfig.deleteSnapshot
		case 4:
			m.featureConfig.consolidateSnaps = !m.featureConfig.consolidateSnaps
		case 5:
			m.featureConfig.enableBandwidthLimit = !m.featureConfig.enableBandwidthLimit
		case 6:
			m.featureConfig.adaptiveBandwidth = !m.featureConfig.adaptiveBandwidth
		case 7:
			m.featureConfig.enableIncremental = !m.featureConfig.enableIncremental
		case 8:
			m.featureConfig.showIncrementalInfo = !m.featureConfig.showIncrementalInfo
		case 9:
			m.featureConfig.enableEmail = !m.featureConfig.enableEmail
		case 10:
			m.featureConfig.emailOnStart = !m.featureConfig.emailOnStart
		case 11:
			m.featureConfig.emailOnComplete = !m.featureConfig.emailOnComplete
		case 12:
			m.featureConfig.enableCleanup = !m.featureConfig.enableCleanup
		case 13:
			m.featureConfig.cleanupDryRun = !m.featureConfig.cleanupDryRun
		}
	case "s", "S":
		// Save and return to previous phase
		m.phase = "select"
		count := m.countEnabledFeatures()
		m.message = fmt.Sprintf("‚úì %d advanced features configured", count)
		return m, nil
	}
	return m, nil
}

func (m tuiModel) handleSearchKeys(msg tea.KeyMsg) (tea.Model, tea.Cmd) {
	var cmd tea.Cmd

	switch msg.Type {
	case tea.KeyCtrlC:
		return m, tea.Quit

	case tea.KeyEscape:
		// Cancel search and return to select
		m.phase = "select"
		m.searchQuery = ""
		m.searchInput.Blur()
		m.applyFiltersAndSort()
		m.message = "Search cancelled"
		return m, nil

	case tea.KeyEnter:
		// Apply search and return to select
		m.phase = "select"
		m.searchQuery = m.searchInput.Value()
		m.searchInput.Blur()
		m.applyFiltersAndSort()
		if m.searchQuery != "" {
			visibleCount := len(m.getVisibleVMs())
			m.message = fmt.Sprintf("üîç Found %d VMs matching '%s'", visibleCount, m.searchQuery)
		}
		return m, nil

	default:
		// Update the search input and filter in real-time
		m.searchInput, cmd = m.searchInput.Update(msg)
		m.searchQuery = m.searchInput.Value()
		m.applyFiltersAndSort()
	}

	return m, cmd
}

func (m tuiModel) handleDetailsKeys(msg tea.KeyMsg) (tea.Model, tea.Cmd) {
	switch msg.String() {
	case "ctrl+c", "q":
		return m, tea.Quit
	case "escape", "i", "I", "enter":
		// Return to selection
		m.phase = "select"
		m.detailsVM = nil
		return m, nil
	}
	return m, nil
}

func (m tuiModel) handleValidationKeys(msg tea.KeyMsg) (tea.Model, tea.Cmd) {
	switch msg.String() {
	case "ctrl+c", "q":
		return m, tea.Quit
	case "escape", "n":
		// Cancel and go back
		m.phase = "confirm"
		m.validationReport = nil
		return m, nil
	case "y", "Y", "enter":
		// Proceed with export if validation passed
		if m.validationReport != nil && m.validationReport.AllPassed {
			m.phase = "export"
			m.currentExport = 0
			m.exportProgress.startTime = time.Now()
			return m, tea.Batch(m.exportNext(), tickCmd())
		}
		// If validation failed, require explicit override
		m.message = "Validation failed! Press 'o' to override and export anyway, or Esc to cancel"
		return m, nil
	case "o", "O":
		// Override validation failures
		m.phase = "export"
		m.currentExport = 0
		m.exportProgress.startTime = time.Now()
		return m, tea.Batch(m.exportNext(), tickCmd())
	}
	return m, nil
}

func (m tuiModel) handleExportKeys(msg tea.KeyMsg) (tea.Model, tea.Cmd) {
	switch msg.String() {
	case "ctrl+c", "q":
		// Cancel ongoing export
		if m.cancelExport != nil {
			m.cancelExport()
			m.message = "Export cancelled by user"
			m.log.Warn("Export cancelled by user")
		}
		// Return to selection
		m.phase = "select"
		m.cancelExport = nil
		return m, nil
	}
	return m, nil
}

// newConfigPanel creates an interactive configuration panel
func (m *tuiModel) newConfigPanel() *configPanelState {
	panel := &configPanelState{
		focusedField: 0,
		fields:       make([]configField, 0),
		isDirty:      false,
	}

	// Helper to create text input
	makeInput := func(placeholder, value string) textinput.Model {
		ti := textinput.New()
		ti.Placeholder = placeholder
		ti.SetValue(value)
		ti.CharLimit = 200
		ti.Width = 60
		return ti
	}

	// Add configuration fields
	fields := []configField{
		{
			label:       "Output Directory",
			key:         "output_dir",
			value:       m.outputDir,
			inputModel:  makeInput("/path/to/exports", m.outputDir),
			fieldType:   "text",
			description: "Directory where VM exports will be saved",
		},
		{
			label:       "Bandwidth Limit (MB/s)",
			key:         "bandwidth_limit",
			value:       fmt.Sprintf("%d", m.featureConfig.bandwidthLimitMBps),
			inputModel:  makeInput("0 = unlimited", fmt.Sprintf("%d", m.featureConfig.bandwidthLimitMBps)),
			fieldType:   "number",
			description: "Maximum upload/download speed (0 for unlimited)",
		},
		{
			label:       "Email SMTP Host",
			key:         "email_smtp_host",
			value:       m.featureConfig.emailSMTPHost,
			inputModel:  makeInput("smtp.example.com", m.featureConfig.emailSMTPHost),
			fieldType:   "text",
			description: "SMTP server hostname for email notifications",
		},
		{
			label:       "Email From Address",
			key:         "email_from",
			value:       m.featureConfig.emailFrom,
			inputModel:  makeInput("exports@example.com", m.featureConfig.emailFrom),
			fieldType:   "text",
			description: "From email address for notifications",
		},
		{
			label:       "Email To Address",
			key:         "email_to",
			value:       m.featureConfig.emailTo,
			inputModel:  makeInput("admin@example.com", m.featureConfig.emailTo),
			fieldType:   "text",
			description: "Recipient email address (comma-separated for multiple)",
		},
		{
			label:       "Keep Snapshots Count",
			key:         "keep_snapshots",
			value:       fmt.Sprintf("%d", m.featureConfig.keepSnapshots),
			inputModel:  makeInput("0 = keep all", fmt.Sprintf("%d", m.featureConfig.keepSnapshots)),
			fieldType:   "number",
			description: "Number of snapshots to retain (0 = keep all)",
		},
		{
			label:       "Cleanup Max Age (days)",
			key:         "cleanup_max_age",
			value:       fmt.Sprintf("%d", m.featureConfig.cleanupMaxAge),
			inputModel:  makeInput("30", fmt.Sprintf("%d", m.featureConfig.cleanupMaxAge)),
			fieldType:   "number",
			description: "Delete exports older than this many days",
		},
		{
			label:       "Cleanup Max Count",
			key:         "cleanup_max_count",
			value:       fmt.Sprintf("%d", m.featureConfig.cleanupMaxCount),
			inputModel:  makeInput("10", fmt.Sprintf("%d", m.featureConfig.cleanupMaxCount)),
			fieldType:   "number",
			description: "Keep only N most recent exports",
		},
	}

	panel.fields = fields
	// Focus first field
	if len(panel.fields) > 0 {
		panel.fields[0].inputModel.Focus()
	}

	return panel
}

// handleConfigPanelKeys handles keyboard input for config panel
func (m tuiModel) handleConfigPanelKeys(msg tea.KeyMsg) (tea.Model, tea.Cmd) {
	if m.configPanel == nil {
		// Initialize config panel if not present
		m.configPanel = m.newConfigPanel()
	}

	panel := m.configPanel

	switch msg.String() {
	case "ctrl+c", "q":
		return m, tea.Quit

	case "escape":
		// Cancel and go back
		m.phase = "confirm"
		m.configPanel = nil
		return m, nil

	case "up", "shift+tab":
		// Move to previous field
		if panel.focusedField > 0 {
			panel.fields[panel.focusedField].inputModel.Blur()
			panel.focusedField--
			panel.fields[panel.focusedField].inputModel.Focus()
		}
		return m, nil

	case "down", "tab":
		// Move to next field
		if panel.focusedField < len(panel.fields)-1 {
			panel.fields[panel.focusedField].inputModel.Blur()
			panel.focusedField++
			panel.fields[panel.focusedField].inputModel.Focus()
		}
		return m, nil

	case "enter":
		// Move to next field or save if at last field
		if panel.focusedField < len(panel.fields)-1 {
			panel.fields[panel.focusedField].inputModel.Blur()
			panel.focusedField++
			panel.fields[panel.focusedField].inputModel.Focus()
		} else {
			// Save configuration
			return m.saveConfigPanel()
		}
		return m, nil

	case "ctrl+s":
		// Save configuration
		return m.saveConfigPanel()

	default:
		// Update the focused field's input model
		var cmd tea.Cmd
		panel.fields[panel.focusedField].inputModel, cmd = panel.fields[panel.focusedField].inputModel.Update(msg)
		panel.isDirty = true
		return m, cmd
	}
}

// saveConfigPanel saves the configuration from the panel
func (m tuiModel) saveConfigPanel() (tea.Model, tea.Cmd) {
	if m.configPanel == nil {
		return m, nil
	}

	// Update model with values from config panel
	for _, field := range m.configPanel.fields {
		value := field.inputModel.Value()
		switch field.key {
		case "output_dir":
			m.outputDir = value
		case "bandwidth_limit":
			if val := parseInt(value); val >= 0 {
				m.featureConfig.bandwidthLimitMBps = val
			}
		case "email_smtp_host":
			m.featureConfig.emailSMTPHost = value
		case "email_from":
			m.featureConfig.emailFrom = value
		case "email_to":
			m.featureConfig.emailTo = value
		case "keep_snapshots":
			if val := parseInt(value); val >= 0 {
				m.featureConfig.keepSnapshots = int(val)
			}
		case "cleanup_max_age":
			if val := parseInt(value); val >= 0 {
				m.featureConfig.cleanupMaxAge = int(val)
			}
		case "cleanup_max_count":
			if val := parseInt(value); val >= 0 {
				m.featureConfig.cleanupMaxCount = int(val)
			}
		}
	}

	m.message = "Configuration saved successfully!"
	m.phase = "confirm"
	m.configPanel = nil
	return m, nil
}

// parseInt parses a string to int64, returns 0 on error
func parseInt(s string) int64 {
	var val int64
	fmt.Sscanf(s, "%d", &val)
	return val
}

// handleStatsKeys handles keyboard input for stats dashboard
func (m tuiModel) handleStatsKeys(msg tea.KeyMsg) (tea.Model, tea.Cmd) {
	switch msg.String() {
	case "ctrl+c", "q":
		return m, tea.Quit
	case "escape":
		// Go back to select screen
		m.phase = "select"
		return m, nil
	}
	return m, nil
}

func (m tuiModel) countEnabledFeatures() int {
	count := 0
	if m.featureConfig.enableSnapshot {
		count++
	}
	if m.featureConfig.enableBandwidthLimit {
		count++
	}
	if m.featureConfig.enableIncremental {
		count++
	}
	if m.featureConfig.enableEmail {
		count++
	}
	if m.featureConfig.enableCleanup {
		count++
	}
	return count
}

func (m tuiModel) View() string {
	switch m.phase {
	case "select":
		return m.renderSelection()
	case "confirm":
		return m.renderConfirm()
	case "regex":
		return m.renderRegex()
	case "template":
		return m.renderTemplate()
	case "features":
		return m.renderFeatures()
	case "search":
		return m.renderSearch()
	case "details":
		return m.renderDetails()
	case "validation":
		return m.renderValidation()
	case "config":
		return m.renderConfigPanel()
	case "stats":
		return m.renderStats()
	case "queue":
		return m.renderQueue()
	case "history":
		return m.renderHistory()
	case "logs":
		return m.renderLogs()
	case "tree":
		return m.renderTree()
	case "preview":
		return m.renderPreview()
	case "actions":
		return m.renderActions()
	case "bulkops":
		return m.renderBulkOps()
	case "compare":
		return m.renderCompare()
	case "bookmarks":
		return m.renderBookmarks()
	case "metrics":
		return m.renderMetrics()
	case "filterbuilder":
		return m.renderFilterBuilder()
	case "snapshots":
		return m.renderSnapshotManager()
	case "resources":
		return m.renderResourcePlanner()
	case "migration":
		return m.renderMigrationWizard()
	case "export":
		return m.renderExport()
	case "cloudupload":
		return m.renderCloudUpload()
	case "done":
		return m.renderDone()
	case "error":
		return errorStyleTUI.Render(fmt.Sprintf("Error: %v\n\nPress q to quit", m.err))
	}
	return "Loading VMs..."
}

// Cool ASCII art banner
func renderCoolBanner() string {
	banner := `
‚ï¶ ‚ï¶‚ï¶ ‚ï¶‚ïî‚ïê‚ïó‚ïî‚ïê‚ïó‚ï¶‚ïê‚ïó  ‚ïî‚ïê‚ïó‚ïê‚ïó ‚ï¶‚ïî‚ïê‚ïó‚ïî‚ïê‚ïó‚ï¶‚ïê‚ïó‚ïî‚ï¶‚ïó
‚ï†‚ïê‚ï£‚ïö‚ï¶‚ïù‚ï†‚ïê‚ïù‚ïë‚ï£ ‚ï†‚ï¶‚ïù  ‚ïë‚ï£ ‚ïî‚ï©‚ï¶‚ïù‚ï†‚ïê‚ïù‚ïë ‚ïë‚ï†‚ï¶‚ïù ‚ïë
‚ï© ‚ï© ‚ï© ‚ï©  ‚ïö‚ïê‚ïù‚ï©‚ïö‚ïê  ‚ïö‚ïê‚ïù‚ï© ‚ïö‚ïê‚ï©  ‚ïö‚ïê‚ïù‚ï©‚ïö‚ïê ‚ï© `

	// Modern gradient styling for the banner
	gradientBanner := lipgloss.NewStyle().
		Foreground(deepOrange).
		Bold(true).
		Render(banner)

	subtitle := lipgloss.NewStyle().
		Foreground(tealInfo).
		Bold(true).
		Render("        ‚ö° Multi-Cloud VM Export Platform ‚ö°")

	// Create a modern bordered box around the banner
	box := lipgloss.NewStyle().
		Border(lipgloss.RoundedBorder()).
		BorderForeground(deepOrange).
		Padding(1, 2).
		Align(lipgloss.Center)

	return box.Render(gradientBanner + "\n" + subtitle)
}

// renderSplitScreen renders a split-screen layout with VM list and details side-by-side
func (m tuiModel) renderSplitScreen() string {
	var b strings.Builder

	// Calculate pane widths based on terminal width
	termWidth := m.getResponsiveWidth()
	leftPaneWidth := termWidth * 45 / 100  // 45% for list
	rightPaneWidth := termWidth * 50 / 100 // 50% for details

	if termWidth < 80 {
		// On narrow terminals, use vertical split instead
		return m.renderVerticalSplit()
	}

	// Header with split screen indicator
	header := lipgloss.NewStyle().
		Foreground(tealInfo).
		Background(darkBg).
		Bold(true).
		Padding(0, 2).
		Border(lipgloss.RoundedBorder()).
		BorderForeground(deepOrange).
		Width(termWidth - 4).
		Render("‚ïî‚ïê‚ïê‚ïê SPLIT VIEW MODE ‚ïê‚ïê‚ïê‚ïó  VMs ‚îÇ Details  (Tab: Switch Pane | V: Exit Split View)")

	b.WriteString(header)
	b.WriteString("\n\n")

	// Render left pane (VM list)
	leftPane := m.renderVMListPane(leftPaneWidth)

	// Render right pane (VM details)
	rightPane := m.renderDetailsPane(rightPaneWidth)

	// Create bordered styles for each pane
	leftStyle := lipgloss.NewStyle().
		Border(lipgloss.RoundedBorder()).
		BorderForeground(func() lipgloss.Color {
			if m.focusedPane == "list" {
				return tealInfo
			}
			return lipgloss.Color("#4B5563")
		}()).
		Width(leftPaneWidth).
		Height(m.termHeight - 10)

	rightStyle := lipgloss.NewStyle().
		Border(lipgloss.RoundedBorder()).
		BorderForeground(func() lipgloss.Color {
			if m.focusedPane == "details" {
				return tealInfo
			}
			return lipgloss.Color("#4B5563")
		}()).
		Width(rightPaneWidth).
		Height(m.termHeight - 10)

	// Join panes horizontally
	panes := lipgloss.JoinHorizontal(
		lipgloss.Top,
		leftStyle.Render(leftPane),
		"  ",
		rightStyle.Render(rightPane),
	)

	b.WriteString(panes)
	b.WriteString("\n")

	// Footer with keyboard shortcuts
	footer := lipgloss.NewStyle().
		Foreground(lipgloss.Color("#6B7280")).
		Italic(true).
		Render("Tab: Switch Pane | ‚Üë/‚Üì: Navigate | Space: Select | Enter: Export | V: Exit Split View | Q: Quit")

	b.WriteString(footer)

	return b.String()
}

// renderVMListPane renders the left pane with VM list
func (m tuiModel) renderVMListPane(width int) string {
	var b strings.Builder

	// Pane title
	title := lipgloss.NewStyle().
		Foreground(tealInfo).
		Bold(true).
		Render(fmt.Sprintf("üìã VM List (%s)", func() string {
			if m.focusedPane == "list" {
				return "ACTIVE"
			}
			return "inactive"
		}()))

	b.WriteString(title)
	b.WriteString("\n\n")

	// Stats
	selectedCount := m.countSelected()
	totalCount := len(m.vms)
	visibleCount := len(m.getVisibleVMs())

	stats := lipgloss.NewStyle().
		Foreground(lipgloss.Color("#9CA3AF")).
		Render(fmt.Sprintf("Total: %d | Visible: %d | Selected: %d", totalCount, visibleCount, selectedCount))

	b.WriteString(stats)
	b.WriteString("\n\n")

	// VM list
	vms := m.getVisibleVMs()
	maxVisible := m.termHeight - 15
	if maxVisible < 5 {
		maxVisible = 5
	}

	start := m.cursor - maxVisible/2
	if start < 0 {
		start = 0
	}
	end := start + maxVisible
	if end > len(vms) {
		end = len(vms)
		start = end - maxVisible
		if start < 0 {
			start = 0
		}
	}

	for i := start; i < end && i < len(vms); i++ {
		vm := vms[i]
		cursor := " "
		if i == m.cursor {
			cursor = "‚ùØ"
		}

		checkbox := "[ ]"
		if vm.selected {
			checkbox = "[‚úì]"
		}

		// Truncate name if too long
		name := vm.vm.Name
		maxNameLen := width - 15
		if len(name) > maxNameLen {
			name = name[:maxNameLen-3] + "..."
		}

		style := lipgloss.NewStyle()
		if i == m.cursor {
			style = style.Foreground(tealInfo).Bold(true)
		} else if vm.selected {
			style = style.Foreground(successGreen)
		}

		line := fmt.Sprintf("%s %s %s", cursor, checkbox, name)
		b.WriteString(style.Render(line))
		b.WriteString("\n")
	}

	return b.String()
}

// renderDetailsPane renders the right pane with VM details
func (m tuiModel) renderDetailsPane(width int) string {
	var b strings.Builder

	// Pane title
	title := lipgloss.NewStyle().
		Foreground(tealInfo).
		Bold(true).
		Render(fmt.Sprintf("üìä VM Details (%s)", func() string {
			if m.focusedPane == "details" {
				return "ACTIVE"
			}
			return "inactive"
		}()))

	b.WriteString(title)
	b.WriteString("\n\n")

	// Get currently selected VM
	vms := m.getVisibleVMs()
	if m.cursor >= len(vms) {
		b.WriteString(lipgloss.NewStyle().
			Foreground(lipgloss.Color("#9CA3AF")).
			Render("No VM selected"))
		return b.String()
	}

	vm := vms[m.cursor].vm

	// VM details
	details := []struct {
		label string
		value string
		color lipgloss.Color
	}{
		{"Name", vm.Name, tealInfo},
		{"Path", vm.Path, lipgloss.Color("#6B7280")},
		{"Power", vm.PowerState, func() lipgloss.Color {
			if vm.PowerState == "poweredOn" {
				return successGreen
			}
			return amberYellow
		}()},
		{"OS", vm.GuestOS, lipgloss.Color("#9CA3AF")},
		{"CPU", fmt.Sprintf("%d cores", vm.NumCPU), lipgloss.Color("#60A5FA")},
		{"Memory", fmt.Sprintf("%d MB", vm.MemoryMB), lipgloss.Color("#34D399")},
		{"Storage", fmt.Sprintf("%.2f GB", float64(vm.Storage)/(1024*1024*1024)), lipgloss.Color("#F59E0B")},
	}

	for _, detail := range details {
		label := lipgloss.NewStyle().
			Foreground(lipgloss.Color("#9CA3AF")).
			Width(12).
			Render(detail.label + ":")

		value := lipgloss.NewStyle().
			Foreground(detail.color).
			Bold(true).
			Render(detail.value)

		b.WriteString(label + " " + value)
		b.WriteString("\n")
	}

	return b.String()
}

// renderVerticalSplit renders a vertical split for narrow terminals
func (m tuiModel) renderVerticalSplit() string {
	var b strings.Builder

	b.WriteString(lipgloss.NewStyle().
		Foreground(tealInfo).
		Bold(true).
		Render("‚ïî‚ïê‚ïê‚ïê SPLIT VIEW (Vertical) ‚ïê‚ïê‚ïê‚ïó"))
	b.WriteString("\n\n")

	// VM List on top
	b.WriteString(m.renderVMListPane(m.termWidth - 4))
	b.WriteString("\n")
	b.WriteString(strings.Repeat("‚îÄ", m.termWidth-4))
	b.WriteString("\n")

	// Details on bottom
	b.WriteString(m.renderDetailsPane(m.termWidth - 4))

	return b.String()
}

func (m tuiModel) renderSelection() string {
	// If split screen mode is enabled, use split screen layout
	if m.splitScreenMode {
		return m.renderSplitScreen()
	}

	var b strings.Builder

	// Cool banner instead of simple title
	b.WriteString(renderCoolBanner())
	b.WriteString("\n\n")

	if len(m.vms) == 0 {
		b.WriteString(infoStyleTUI.Render("Loading VMs..."))
		return b.String()
	}

	// Cool status bar with gradient background
	selectedCount := m.countSelected()
	totalCount := len(m.vms)
	visibleCount := len(m.getVisibleVMs())

	// Create modern status bar
	statusBar := lipgloss.NewStyle().
		Foreground(tealInfo).
		Background(darkBg).
		Bold(true).
		Padding(0, 2).
		Border(lipgloss.RoundedBorder()).
		BorderForeground(deepOrange).
		Width(80)

	statusParts := []string{
		lipgloss.NewStyle().Foreground(tealInfo).Render(fmt.Sprintf("üìä %d Total", totalCount)),
		lipgloss.NewStyle().Foreground(tealInfo).Render(fmt.Sprintf("üëÅ  %d Visible", visibleCount)),
		lipgloss.NewStyle().Foreground(successGreen).Render(fmt.Sprintf("‚úì %d Selected", selectedCount)),
	}

	if m.searchQuery != "" {
		statusParts = append(statusParts, lipgloss.NewStyle().Foreground(deepOrange).Render(fmt.Sprintf("üîç %s", m.searchQuery)))
	}
	if m.filterPower != "" {
		statusParts = append(statusParts, lipgloss.NewStyle().Foreground(amberYellow).Render(fmt.Sprintf("‚ö° %s", m.filterPower)))
	}

	b.WriteString(statusBar.Render(strings.Join(statusParts, " ‚îÇ ")))
	b.WriteString("\n\n")

	// Animated hint message with glowing effect
	var hintMsg string
	var hintStyle lipgloss.Style

	if selectedCount == 0 {
		hintMsg = "üí° Press SPACE to select VMs ‚îÇ A to select all ‚îÇ ENTER to continue"
		hintStyle = lipgloss.NewStyle().
			Foreground(deepOrange).
			Background(lightCharcoal).
			Italic(true).
			Padding(0, 2).
			Border(lipgloss.RoundedBorder()).
			BorderForeground(deepOrange)
	} else if selectedCount == 1 {
		hintMsg = fmt.Sprintf("‚úì 1 VM selected ‚îÇ Select more with SPACE ‚îÇ %d VMs available", visibleCount-1)
		hintStyle = lipgloss.NewStyle().
			Foreground(successGreen).
			Background(darkBg).
			Bold(true).
			Padding(0, 2).
			Border(lipgloss.RoundedBorder()).
			BorderForeground(successGreen)
	} else {
		hintMsg = fmt.Sprintf("üöÄ %d VMs ready for export ‚îÇ Press ENTER to continue", selectedCount)
		hintStyle = lipgloss.NewStyle().
			Foreground(successGreen).
			Background(darkBg).
			Bold(true).
			Padding(0, 2).
			Border(lipgloss.DoubleBorder()).
			BorderForeground(tealInfo)
	}

	b.WriteString(hintStyle.Render(hintMsg))
	b.WriteString("\n\n")

	// VM list with proper bounds checking
	vms := m.getVisibleVMs()

	// Safe cursor position for rendering
	safeCursor := m.cursor
	if safeCursor >= len(vms) && len(vms) > 0 {
		safeCursor = len(vms) - 1
	}
	if safeCursor < 0 {
		safeCursor = 0
	}

	start := safeCursor - 10
	if start < 0 {
		start = 0
	}
	end := start + 20
	if end > len(vms) {
		end = len(vms)
	}

	// Create a bordered container for VM list
	vmListBox := lipgloss.NewStyle().
		Border(lipgloss.RoundedBorder()).
		BorderForeground(deepOrange).
		Padding(1, 2)

	var vmListContent strings.Builder

	for i := start; i < end && i < len(vms); i++ {
		item := vms[i]

		// Cool cursor with neon effect
		cursor := "   "
		cursorStyle := lipgloss.NewStyle()
		if safeCursor == i {
			cursor = " ‚ñ∂ "
			cursorStyle = lipgloss.NewStyle().Foreground(tealInfo).Bold(true)
		}

		// Animated checkbox with glow effect
		checkbox := "‚òê "
		checkboxStyle := lipgloss.NewStyle().Foreground(mutedGray)
		if item.selected {
			checkbox = "‚òë "
			checkboxStyle = lipgloss.NewStyle().
				Foreground(successGreen).
				Bold(true)
		}

		// Power state with cool icons
		var powerIcon string
		var powerColor lipgloss.Color
		if item.vm.PowerState == "poweredOn" {
			powerIcon = "‚ö°"
			powerColor = successGreen
		} else {
			powerIcon = "‚óã"
			powerColor = mutedGray
		}
		powerStyle := lipgloss.NewStyle().Foreground(powerColor)

		// VM name with dynamic styling
		vmNameStyle := lipgloss.NewStyle().Foreground(tealInfo)
		if item.selected {
			vmNameStyle = lipgloss.NewStyle().
				Foreground(successGreen).
				Bold(true)
		}
		if safeCursor == i {
			vmNameStyle = vmNameStyle.Background(lightBg)
		}

		// Resource info with color coding
		cpuInfo := lipgloss.NewStyle().Foreground(tealInfo).Render(fmt.Sprintf("%2dC", item.vm.NumCPU))
		memInfo := lipgloss.NewStyle().Foreground(amberYellow).Render(fmt.Sprintf("%4.0fG", float64(item.vm.MemoryMB)/1024))
		storageInfo := lipgloss.NewStyle().Foreground(deepOrange).Render(formatBytesCompact(item.vm.Storage))

		// Construct the line with all components
		line := fmt.Sprintf("%s%s%s %-35s %s %s %s %s",
			cursorStyle.Render(cursor),
			checkboxStyle.Render(checkbox),
			powerStyle.Render(powerIcon),
			vmNameStyle.Render(truncateString(item.vm.Name, 35)),
			cpuInfo,
			memInfo,
			storageInfo,
			"",
		)

		// Add selection highlight
		if safeCursor == i {
			lineStyle := lipgloss.NewStyle().
				Background(lightBg).
				Foreground(tealInfo).
				Width(78)
			vmListContent.WriteString(lineStyle.Render(line))
		} else {
			vmListContent.WriteString(line)
		}
		vmListContent.WriteString("\n")
	}

	b.WriteString(vmListBox.Render(vmListContent.String()))
	b.WriteString("\n")

	// Modern help section
	b.WriteString("\n")
	b.WriteString(lipgloss.NewStyle().
		Border(lipgloss.RoundedBorder(), true, false, false, false).
		BorderForeground(primaryColor).
		Foreground(mutedColor).
		Padding(1, 0).
		Render(""))
	b.WriteString("\n")

	if m.showHelp {
		// Full help with all keybindings
		helpView := m.helpModel.FullHelpView(m.keys.FullHelp())
		b.WriteString(lipgloss.NewStyle().
			Foreground(mutedColor).
			Italic(true).
			Render(helpView))
	} else {
		// Short help with essential keys
		shortHelp := m.helpModel.ShortHelpView(m.keys.ShortHelp())
		b.WriteString(lipgloss.NewStyle().
			Foreground(mutedColor).
			Italic(true).
			Render("üí° " + shortHelp))
	}

	if m.message != "" {
		b.WriteString("\n\n")
		b.WriteString(infoStyleTUI.Render(m.message))
	}

	return b.String()
}

func (m tuiModel) renderConfirm() string {
	var b strings.Builder

	b.WriteString(titleStyleTUI.Render("üìã Confirm Export"))
	b.WriteString("\n\n")

	selectedVMs := []tuiVMItem{}
	for _, item := range m.vms {
		if item.selected {
			selectedVMs = append(selectedVMs, item)
		}
	}

	var totalStorage int64
	var totalCPUs int32
	var totalMemory int32

	for _, item := range selectedVMs {
		totalStorage += item.vm.Storage
		totalCPUs += item.vm.NumCPU
		totalMemory += item.vm.MemoryMB

		vmDetails := fmt.Sprintf("üì¶ %s | %d CPU | %.1f GB | %s",
			item.vm.Name,
			item.vm.NumCPU,
			float64(item.vm.MemoryMB)/1024,
			formatBytesCompact(item.vm.Storage))
		b.WriteString(selectedStyleTUI.Render(vmDetails))
		b.WriteString("\n")
	}

	b.WriteString("\n")
	b.WriteString(titleStyleTUI.Render("üìä Summary"))
	b.WriteString("\n")
	summary := fmt.Sprintf("VMs: %d | CPUs: %d | Memory: %.1f GB | Storage: %s",
		len(selectedVMs),
		totalCPUs,
		float64(totalMemory)/1024,
		formatBytesCompact(totalStorage))
	b.WriteString(infoStyleTUI.Render(summary))
	b.WriteString("\n\n")

	// Cloud upload info
	if m.enableCloudUpload && m.cloudConfig != nil {
		b.WriteString(titleStyleTUI.Render("‚òÅÔ∏è  Cloud Upload"))
		b.WriteString("\n")
		cloudInfo := fmt.Sprintf("Provider: %s | Bucket: %s",
			m.cloudConfig.provider,
			m.cloudConfig.bucket)
		if m.cloudConfig.prefix != "" {
			cloudInfo += fmt.Sprintf(" | Prefix: %s", m.cloudConfig.prefix)
		}
		b.WriteString(successStyleTUI.Render("‚úì " + cloudInfo))
		b.WriteString("\n\n")
	} else {
		b.WriteString(infoStyleTUI.Render("‚òÅÔ∏è  Cloud upload: Not configured (press 'u' to configure)"))
		b.WriteString("\n\n")
	}

	// Advanced features info
	enabledCount := m.countEnabledFeatures()
	if enabledCount > 0 {
		b.WriteString(titleStyleTUI.Render("‚ö° Advanced Features"))
		b.WriteString("\n")
		features := []string{}
		if m.featureConfig.enableSnapshot {
			features = append(features, "Snapshots")
		}
		if m.featureConfig.enableBandwidthLimit {
			features = append(features, "Bandwidth Limiting")
		}
		if m.featureConfig.enableIncremental {
			features = append(features, "Incremental Export")
		}
		if m.featureConfig.enableEmail {
			features = append(features, "Email Notifications")
		}
		if m.featureConfig.enableCleanup {
			features = append(features, "Cleanup")
		}
		b.WriteString(successStyleTUI.Render(fmt.Sprintf("‚úì Enabled: %s", strings.Join(features, ", "))))
		b.WriteString("\n\n")
	} else {
		b.WriteString(infoStyleTUI.Render("‚ö° Advanced features: Not configured (press 'f' to configure)"))
		b.WriteString("\n\n")
	}

	// Disk space check
	diskSpace := getDiskSpace(m.outputDir)
	if diskSpace > totalStorage {
		b.WriteString(successStyleTUI.Render(fmt.Sprintf("‚úì Disk space OK: %s available", formatBytesCompact(diskSpace))))
	} else {
		b.WriteString(errorStyleTUI.Render(fmt.Sprintf("‚ö† WARNING: Need %s, only %s available!", formatBytesCompact(totalStorage), formatBytesCompact(diskSpace))))
	}

	b.WriteString("\n\n")
	b.WriteString(helpStyleTUI.Render("y/Enter: Validate & export | p: Preview | v: Validation only | c: Config | u: Cloud | f: Features | n/Esc: Back | q: Quit"))

	return b.String()
}

func (m tuiModel) renderRegex() string {
	var b strings.Builder

	b.WriteString(titleStyleTUI.Render("üéØ Bulk Selection by Pattern"))
	b.WriteString("\n\n")
	b.WriteString(infoStyleTUI.Render("Enter regex pattern to match VM names:"))
	b.WriteString("\n\n")

	b.WriteString(selectedStyleTUI.Render(fmt.Sprintf("Pattern: %s‚ñà", m.regexPattern)))
	b.WriteString("\n\n")

	if m.regexPattern != "" {
		matches := 0
		for _, item := range m.vms {
			if matchVMPattern(item.vm.Name, m.regexPattern) {
				matches++
			}
		}
		if matches > 0 {
			b.WriteString(successStyleTUI.Render(fmt.Sprintf("‚úì Matches %d VMs", matches)))
		} else {
			b.WriteString(errorStyleTUI.Render("‚ö† No matches"))
		}
		b.WriteString("\n")
	}

	b.WriteString("\n")
	b.WriteString(helpStyleTUI.Render("Enter: Select | Esc: Cancel | Backspace: Delete"))

	return b.String()
}

func (m tuiModel) renderSearch() string {
	var b strings.Builder

	b.WriteString(titleStyleTUI.Render("üîç Live Search"))
	b.WriteString("\n\n")
	b.WriteString(infoStyleTUI.Render("Search VMs by name or path (type to filter in real-time):"))
	b.WriteString("\n\n")

	// Search input box
	searchBox := lipgloss.NewStyle().
		Border(lipgloss.RoundedBorder()).
		BorderForeground(deepOrange).
		Padding(0, 1).
		Width(60)

	b.WriteString(searchBox.Render(m.searchInput.View()))
	b.WriteString("\n\n")

	// Show matching results in real-time
	visibleVMs := m.getVisibleVMs()
	if m.searchQuery != "" {
		if len(visibleVMs) > 0 {
			resultStyle := lipgloss.NewStyle().Foreground(successGreen).Bold(true)
			b.WriteString(resultStyle.Render(fmt.Sprintf("‚úì %d VMs match your search", len(visibleVMs))))
			b.WriteString("\n\n")

			// Show preview of matches
			previewCount := 10
			if len(visibleVMs) < previewCount {
				previewCount = len(visibleVMs)
			}

			previewBox := lipgloss.NewStyle().
				Border(lipgloss.RoundedBorder()).
				BorderForeground(mutedGray).
				Padding(1, 2).
				Width(70)

			var previewList strings.Builder
			for i := 0; i < previewCount; i++ {
				vm := visibleVMs[i]
				// Highlight matching text
				name := highlightMatch(vm.vm.Name, m.searchQuery)
				previewList.WriteString(fmt.Sprintf("  ‚Ä¢ %s\n", name))
			}

			if len(visibleVMs) > previewCount {
				previewList.WriteString(lipgloss.NewStyle().Foreground(mutedGray).Render(
					fmt.Sprintf("  ... and %d more", len(visibleVMs)-previewCount)))
			}

			b.WriteString(previewBox.Render(previewList.String()))
		} else {
			b.WriteString(errorStyleTUI.Render("‚ö† No VMs match your search"))
		}
	} else {
		hintStyle := lipgloss.NewStyle().Foreground(mutedGray).Italic(true)
		b.WriteString(hintStyle.Render(fmt.Sprintf("üí° %d VMs available. Start typing to filter...", len(m.vms))))
	}

	b.WriteString("\n\n")
	b.WriteString(helpStyleTUI.Render("Enter: Apply search | Esc: Cancel | Type: Filter in real-time"))

	return b.String()
}

// highlightMatch highlights matching substring in text
func highlightMatch(text, query string) string {
	if query == "" {
		return text
	}

	lowerText := strings.ToLower(text)
	lowerQuery := strings.ToLower(query)
	index := strings.Index(lowerText, lowerQuery)

	if index == -1 {
		return text
	}

	before := text[:index]
	match := text[index : index+len(query)]
	after := text[index+len(query):]

	highlightStyle := lipgloss.NewStyle().Foreground(deepOrange).Background(lightCharcoal).Bold(true)
	return before + highlightStyle.Render(match) + after
}

func (m tuiModel) renderDetails() string {
	var b strings.Builder

	if m.detailsVM == nil {
		return errorStyleTUI.Render("No VM selected for details")
	}

	vm := *m.detailsVM

	// Header
	header := lipgloss.NewStyle().
		Bold(true).
		Foreground(primaryColor).
		Background(lightCharcoal).
		Width(80).
		Align(lipgloss.Center).
		Render("üñ•Ô∏è  VM Information")
	b.WriteString(header)
	b.WriteString("\n\n")

	// Main info box
	mainInfoBox := lipgloss.NewStyle().
		Border(lipgloss.DoubleBorder()).
		BorderForeground(deepOrange).
		Padding(1, 2).
		Width(76)

	var mainInfo strings.Builder

	// VM Name
	mainInfo.WriteString(lipgloss.NewStyle().
		Foreground(successGreen).
		Bold(true).
		Render(fmt.Sprintf("üè∑Ô∏è  Name: %s", vm.Name)))
	mainInfo.WriteString("\n\n")

	// Power State
	var powerIcon string
	var powerColor lipgloss.Color
	if vm.PowerState == "poweredOn" {
		powerIcon = "‚ö°"
		powerColor = successGreen
	} else {
		powerIcon = "‚óã"
		powerColor = mutedGray
	}
	mainInfo.WriteString(lipgloss.NewStyle().Foreground(powerColor).Render(
		fmt.Sprintf("%s Power State: %s", powerIcon, vm.PowerState)))
	mainInfo.WriteString("\n\n")

	// Guest OS
	mainInfo.WriteString(lipgloss.NewStyle().Foreground(tealInfo).Render(
		fmt.Sprintf("üíø Guest OS: %s", vm.GuestOS)))
	mainInfo.WriteString("\n\n")

	// Path
	mainInfo.WriteString(lipgloss.NewStyle().Foreground(mutedGray).Render(
		fmt.Sprintf("üìÅ Path: %s", vm.Path)))

	b.WriteString(mainInfoBox.Render(mainInfo.String()))
	b.WriteString("\n\n")

	// Resources section
	resourcesBox := lipgloss.NewStyle().
		Border(lipgloss.RoundedBorder()).
		BorderForeground(tealInfo).
		Padding(1, 2).
		Width(76)

	var resources strings.Builder
	resources.WriteString(lipgloss.NewStyle().
		Foreground(tealInfo).
		Bold(true).
		Render("‚öôÔ∏è  Resources"))
	resources.WriteString("\n\n")

	// CPU
	resources.WriteString(lipgloss.NewStyle().Foreground(amberYellow).Render(
		fmt.Sprintf("  üî¢ vCPUs:         %d", vm.NumCPU)))
	resources.WriteString("\n")

	// Memory
	memoryGB := float64(vm.MemoryMB) / 1024.0
	resources.WriteString(lipgloss.NewStyle().Foreground(amberYellow).Render(
		fmt.Sprintf("  üß† Memory:        %d MB (%.1f GB)", vm.MemoryMB, memoryGB)))
	resources.WriteString("\n")

	// Storage
	storageGB := float64(vm.Storage) / (1024 * 1024 * 1024)
	resources.WriteString(lipgloss.NewStyle().Foreground(amberYellow).Render(
		fmt.Sprintf("  üíæ Storage:       %s (%.1f GB)", formatBytes(vm.Storage), storageGB)))

	b.WriteString(resourcesBox.Render(resources.String()))
	b.WriteString("\n\n")

	// Estimated export size
	estimateBox := lipgloss.NewStyle().
		Border(lipgloss.RoundedBorder()).
		BorderForeground(warningColor).
		Padding(1, 2).
		Width(76)

	var estimate strings.Builder
	estimate.WriteString(lipgloss.NewStyle().
		Foreground(warningColor).
		Bold(true).
		Render("üì¶ Export Information"))
	estimate.WriteString("\n\n")

	estimate.WriteString(lipgloss.NewStyle().Foreground(textColor).Render(
		fmt.Sprintf("  Estimated Size:   ~%s", formatBytes(vm.Storage))))
	estimate.WriteString("\n")

	// Check disk space
	diskSpace := getDiskSpace(m.outputDir)
	if diskSpace > vm.Storage {
		estimate.WriteString(lipgloss.NewStyle().Foreground(successGreen).Render(
			fmt.Sprintf("  Available Space:  %s ‚úì", formatBytes(diskSpace))))
	} else {
		estimate.WriteString(lipgloss.NewStyle().Foreground(errorColor).Render(
			fmt.Sprintf("  Available Space:  %s ‚ö† INSUFFICIENT!", formatBytes(diskSpace))))
	}

	b.WriteString(estimateBox.Render(estimate.String()))
	b.WriteString("\n\n")

	// Help
	b.WriteString(helpStyleTUI.Render("Press i/Esc/Enter to return to VM list"))

	return b.String()
}

func (m tuiModel) renderTemplate() string {
	var b strings.Builder

	b.WriteString(titleStyleTUI.Render("üìã Export Templates"))
	b.WriteString("\n\n")

	for i, tmpl := range exportTemplates {
		cursor := "  "
		if i == m.cursor {
			cursor = "‚ñ∂ "
		}

		style := unselectedStyleTUI
		if i == m.cursor {
			style = selectedStyleTUI
		}

		header := fmt.Sprintf("%s[%d] %s", cursor, i+1, tmpl.name)
		b.WriteString(style.Bold(true).Render(header))
		b.WriteString("\n")
		b.WriteString(infoStyleTUI.Render(fmt.Sprintf("    %s", tmpl.description)))
		b.WriteString("\n")
		settings := fmt.Sprintf("    Format: %s | Compress: %v | Verify: %v",
			tmpl.format, tmpl.compress, tmpl.verify)
		b.WriteString(helpStyleTUI.Render(settings))
		b.WriteString("\n\n")
	}

	b.WriteString(helpStyleTUI.Render("‚Üë/‚Üì: Navigate | Enter/1-4: Select | Esc: Back"))

	return b.String()
}

func (m tuiModel) renderValidation() string {
	var b strings.Builder

	boxWidth := m.getBoxWidth()
	headerWidth := m.getHeaderWidth()

	// Header
	header := lipgloss.NewStyle().
		Bold(true).
		Foreground(primaryColor).
		Background(lightCharcoal).
		Width(headerWidth).
		Align(lipgloss.Center).
		Render("üîç Pre-Export Validation")
	b.WriteString(header)
	b.WriteString("\n\n")

	if m.validationReport == nil {
		// Show animated loading spinner
		frames := getSpinnerFrames()
		spinnerChar := frames[m.animFrame%len(frames)]
		b.WriteString(spinnerLoadingStyleTUI.Render(spinnerChar))
		b.WriteString(" ")
		b.WriteString(lipgloss.NewStyle().Foreground(tealInfo).Render("Running validation checks..."))
		return b.String()
	}

	report := m.validationReport

	// Overall status
	var statusBox string
	if report.AllPassed {
		statusBox = lipgloss.NewStyle().
			Border(lipgloss.RoundedBorder()).
			BorderForeground(successGreen).
			Padding(1, 2).
			Width(boxWidth).
			Render(lipgloss.NewStyle().
				Foreground(successGreen).
				Bold(true).
				Render("‚úì All validation checks passed!"))
	} else {
		statusBox = lipgloss.NewStyle().
			Border(lipgloss.RoundedBorder()).
			BorderForeground(errorColor).
			Padding(1, 2).
			Width(boxWidth).
			Render(lipgloss.NewStyle().
				Foreground(errorColor).
				Bold(true).
				Render("‚ö† Some validation checks failed"))
	}
	b.WriteString(statusBox)
	b.WriteString("\n\n")

	// Validation checks
	checksBox := lipgloss.NewStyle().
		Border(lipgloss.RoundedBorder()).
		BorderForeground(mutedGray).
		Padding(1, 2).
		Width(boxWidth)

	var checks strings.Builder
	for _, check := range report.Checks {
		var icon string
		var style lipgloss.Style

		if !check.Passed {
			icon = "‚úó"
			style = lipgloss.NewStyle().Foreground(errorColor).Bold(true)
		} else if check.Warning {
			icon = "‚ö†"
			style = lipgloss.NewStyle().Foreground(warningColor)
		} else {
			icon = "‚úì"
			style = lipgloss.NewStyle().Foreground(successGreen)
		}

		checkLine := fmt.Sprintf("%s %-25s %s",
			style.Render(icon),
			check.Name,
			check.Message)
		checks.WriteString(checkLine)
		checks.WriteString("\n")
	}

	b.WriteString(checksBox.Render(checks.String()))
	b.WriteString("\n\n")

	// Warnings summary
	if report.HasWarnings {
		warningBox := lipgloss.NewStyle().
			Border(lipgloss.RoundedBorder()).
			BorderForeground(warningColor).
			Padding(0, 1)

		b.WriteString(warningBox.Render(
			lipgloss.NewStyle().Foreground(warningColor).Render(
				"‚ö† Review warnings above before proceeding")))
		b.WriteString("\n\n")
	}

	// Help text
	if report.AllPassed {
		b.WriteString(helpStyleTUI.Render("y/Enter: Start export | Esc: Go back | q: Quit"))
	} else {
		b.WriteString(helpStyleTUI.Render("o: Override and export anyway | Esc: Go back | q: Quit"))
	}

	if m.message != "" {
		b.WriteString("\n\n")
		b.WriteString(errorStyleTUI.Render(m.message))
	}

	return b.String()
}

// renderConfigPanel renders the interactive configuration panel
func (m tuiModel) renderConfigPanel() string {
	var b strings.Builder

	boxWidth := m.getBoxWidth()
	headerWidth := m.getHeaderWidth()

	// Header
	header := lipgloss.NewStyle().
		Bold(true).
		Foreground(primaryColor).
		Background(lightCharcoal).
		Width(headerWidth).
		Align(lipgloss.Center).
		Render("‚öôÔ∏è  Configuration Editor")
	b.WriteString(header)
	b.WriteString("\n\n")

	if m.configPanel == nil {
		return errorStyleTUI.Render("Config panel not initialized")
	}

	panel := m.configPanel

	// Instructions box
	instructionsBox := lipgloss.NewStyle().
		Border(lipgloss.RoundedBorder()).
		BorderForeground(tealInfo).
		Padding(0, 1).
		Width(boxWidth)

	instructions := lipgloss.NewStyle().Foreground(tealInfo).Render(
		"üí° Use ‚Üë/‚Üì or Tab/Shift+Tab to navigate | Enter to move to next field | Ctrl+S to save")
	b.WriteString(instructionsBox.Render(instructions))
	b.WriteString("\n\n")

	// Render each config field
	for i, field := range panel.fields {
		isFocused := i == panel.focusedField

		// Field box styling
		var fieldBox lipgloss.Style
		if isFocused {
			fieldBox = lipgloss.NewStyle().
				Border(lipgloss.RoundedBorder()).
				BorderForeground(primaryColor).
				Padding(1, 2).
				Width(boxWidth)
		} else {
			fieldBox = lipgloss.NewStyle().
				Border(lipgloss.RoundedBorder()).
				BorderForeground(mutedGray).
				Padding(1, 2).
				Width(boxWidth)
		}

		// Field content
		var fieldContent strings.Builder

		// Label
		labelStyle := lipgloss.NewStyle().
			Bold(true)
		if isFocused {
			labelStyle = labelStyle.Foreground(primaryColor)
		} else {
			labelStyle = labelStyle.Foreground(textColor)
		}
		fieldContent.WriteString(labelStyle.Render(field.label))
		fieldContent.WriteString("\n")

		// Description
		descStyle := lipgloss.NewStyle().
			Foreground(mutedGray).
			Italic(true)
		fieldContent.WriteString(descStyle.Render(field.description))
		fieldContent.WriteString("\n\n")

		// Input field
		fieldContent.WriteString(field.inputModel.View())

		b.WriteString(fieldBox.Render(fieldContent.String()))
		b.WriteString("\n")
	}

	// Status message
	if panel.isDirty {
		b.WriteString("\n")
		statusBox := lipgloss.NewStyle().
			Border(lipgloss.RoundedBorder()).
			BorderForeground(warningColor).
			Padding(0, 1)
		b.WriteString(statusBox.Render(
			lipgloss.NewStyle().Foreground(warningColor).Render(
				"‚ö† Unsaved changes")))
	}

	b.WriteString("\n\n")

	// Help text
	b.WriteString(helpStyleTUI.Render(
		"Ctrl+S or Enter on last field: Save | Esc: Cancel | q: Quit"))

	return b.String()
}

// renderStats renders the statistics dashboard
func (m tuiModel) renderStats() string {
	var b strings.Builder

	boxWidth := m.getBoxWidth()
	headerWidth := m.getHeaderWidth()

	// Header
	header := lipgloss.NewStyle().
		Bold(true).
		Foreground(primaryColor).
		Background(lightCharcoal).
		Width(headerWidth).
		Align(lipgloss.Center).
		Render("üìä Statistics Dashboard")
	b.WriteString(header)
	b.WriteString("\n\n")

	// VM Inventory Statistics
	var totalVMs int
	var poweredOn, poweredOff int
	var totalCPUs int32
	var totalMemoryMB int32
	var totalStorageBytes int64

	for _, vm := range m.vms {
		totalVMs++
		totalCPUs += vm.vm.NumCPU
		totalMemoryMB += vm.vm.MemoryMB
		totalStorageBytes += vm.vm.Storage
		if vm.vm.PowerState == "poweredOn" {
			poweredOn++
		} else {
			poweredOff++
		}
	}

	// VM Inventory Box
	inventoryBox := lipgloss.NewStyle().
		Border(lipgloss.RoundedBorder()).
		BorderForeground(tealInfo).
		Padding(1, 2).
		Width(boxWidth)

	var inventory strings.Builder
	inventory.WriteString(lipgloss.NewStyle().
		Foreground(tealInfo).
		Bold(true).
		Render("üñ•Ô∏è  VM Inventory"))
	inventory.WriteString("\n\n")

	inventory.WriteString(fmt.Sprintf("Total VMs: %s\n",
		lipgloss.NewStyle().Foreground(primaryColor).Bold(true).Render(fmt.Sprintf("%d", totalVMs))))
	inventory.WriteString(fmt.Sprintf("  ‚óè Powered On: %s\n",
		lipgloss.NewStyle().Foreground(successGreen).Render(fmt.Sprintf("%d", poweredOn))))
	inventory.WriteString(fmt.Sprintf("  ‚óã Powered Off: %s\n",
		lipgloss.NewStyle().Foreground(mutedGray).Render(fmt.Sprintf("%d", poweredOff))))
	inventory.WriteString("\n")
	inventory.WriteString(fmt.Sprintf("Total vCPUs: %s\n",
		lipgloss.NewStyle().Foreground(textColor).Render(fmt.Sprintf("%d", totalCPUs))))
	inventory.WriteString(fmt.Sprintf("Total Memory: %s\n",
		lipgloss.NewStyle().Foreground(textColor).Render(fmt.Sprintf("%.1f GB", float64(totalMemoryMB)/1024))))
	inventory.WriteString(fmt.Sprintf("Total Storage: %s\n",
		lipgloss.NewStyle().Foreground(textColor).Render(formatBytes(totalStorageBytes))))

	b.WriteString(inventoryBox.Render(inventory.String()))
	b.WriteString("\n\n")

	// Selected VMs Box
	selectedCount := m.countSelected()
	if selectedCount > 0 {
		var selectedCPUs int32
		var selectedMemoryMB int32
		var selectedStorageBytes int64

		for _, vm := range m.vms {
			if vm.selected {
				selectedCPUs += vm.vm.NumCPU
				selectedMemoryMB += vm.vm.MemoryMB
				selectedStorageBytes += vm.vm.Storage
			}
		}

		selectedBox := lipgloss.NewStyle().
			Border(lipgloss.RoundedBorder()).
			BorderForeground(primaryColor).
			Padding(1, 2).
			Width(boxWidth)

		var selected strings.Builder
		selected.WriteString(lipgloss.NewStyle().
			Foreground(primaryColor).
			Bold(true).
			Render("‚úì Selected for Export"))
		selected.WriteString("\n\n")

		selected.WriteString(fmt.Sprintf("Selected VMs: %s\n",
			lipgloss.NewStyle().Foreground(primaryColor).Bold(true).Render(fmt.Sprintf("%d", selectedCount))))
		selected.WriteString(fmt.Sprintf("Total vCPUs: %s\n",
			lipgloss.NewStyle().Foreground(textColor).Render(fmt.Sprintf("%d", selectedCPUs))))
		selected.WriteString(fmt.Sprintf("Total Memory: %s\n",
			lipgloss.NewStyle().Foreground(textColor).Render(fmt.Sprintf("%.1f GB", float64(selectedMemoryMB)/1024))))
		selected.WriteString(fmt.Sprintf("Total Storage: %s\n",
			lipgloss.NewStyle().Foreground(textColor).Render(formatBytes(selectedStorageBytes))))

		b.WriteString(selectedBox.Render(selected.String()))
		b.WriteString("\n\n")
	}

	// Configuration Summary Box
	configBox := lipgloss.NewStyle().
		Border(lipgloss.RoundedBorder()).
		BorderForeground(amberYellow).
		Padding(1, 2).
		Width(boxWidth)

	var configSummary strings.Builder
	configSummary.WriteString(lipgloss.NewStyle().
		Foreground(amberYellow).
		Bold(true).
		Render("‚öôÔ∏è  Configuration"))
	configSummary.WriteString("\n\n")

	configSummary.WriteString(fmt.Sprintf("Output Directory: %s\n",
		lipgloss.NewStyle().Foreground(textColor).Render(m.outputDir)))

	if m.enableCloudUpload && m.cloudConfig != nil {
		configSummary.WriteString(fmt.Sprintf("Cloud Upload: %s (%s)\n",
			lipgloss.NewStyle().Foreground(successGreen).Render("Enabled"),
			m.cloudConfig.provider))
	} else {
		configSummary.WriteString(fmt.Sprintf("Cloud Upload: %s\n",
			lipgloss.NewStyle().Foreground(mutedGray).Render("Disabled")))
	}

	enabledFeatures := m.countEnabledFeatures()
	if enabledFeatures > 0 {
		configSummary.WriteString(fmt.Sprintf("Advanced Features: %s\n",
			lipgloss.NewStyle().Foreground(successGreen).Render(fmt.Sprintf("%d enabled", enabledFeatures))))
	} else {
		configSummary.WriteString(fmt.Sprintf("Advanced Features: %s\n",
			lipgloss.NewStyle().Foreground(mutedGray).Render("None")))
	}

	b.WriteString(configBox.Render(configSummary.String()))
	b.WriteString("\n\n")

	// Help text
	b.WriteString(helpStyleTUI.Render("Esc: Back to VM list | q: Quit"))

	return b.String()
}

func (m tuiModel) renderFeatures() string {
	var b strings.Builder

	b.WriteString(titleStyleTUI.Render("‚ö° Advanced Features Configuration"))
	b.WriteString("\n\n")

	// Feature options
	features := []struct {
		name        string
		description string
		enabled     bool
	}{
		// Snapshot features
		{"Snapshot Management", "Create VM snapshots before export", m.featureConfig.enableSnapshot},
		{"  Include Memory", "Include VM memory in snapshot", m.featureConfig.snapshotMemory},
		{"  Quiesce Filesystem", "Quiesce filesystem for consistency", m.featureConfig.snapshotQuiesce},
		{"  Delete After Export", "Remove snapshot after export completes", m.featureConfig.deleteSnapshot},
		{"  Consolidate Snapshots", "Merge all snapshots into base disks", m.featureConfig.consolidateSnaps},

		// Bandwidth limiting
		{"Bandwidth Limiting", "Control network bandwidth usage", m.featureConfig.enableBandwidthLimit},
		{"  Adaptive Bandwidth", "Automatically adjust based on network", m.featureConfig.adaptiveBandwidth},

		// Incremental export
		{"Incremental Export", "Export only changed disks", m.featureConfig.enableIncremental},
		{"  Show Analysis Only", "Preview savings without exporting", m.featureConfig.showIncrementalInfo},

		// Email notifications
		{"Email Notifications", "Send email alerts for export events", m.featureConfig.enableEmail},
		{"  Email on Start", "Notify when export starts", m.featureConfig.emailOnStart},
		{"  Email on Complete", "Notify when export completes", m.featureConfig.emailOnComplete},

		// Cleanup
		{"Export Cleanup", "Automatically clean up old exports", m.featureConfig.enableCleanup},
		{"  Dry Run Mode", "Preview cleanup without deleting", m.featureConfig.cleanupDryRun},
	}

	for i, feature := range features {
		cursor := "  "
		if i == m.cursor {
			cursor = "‚ñ∂ "
		}

		checkbox := "[ ]"
		if feature.enabled {
			checkbox = "[‚úì]"
		}

		style := unselectedStyleTUI
		if i == m.cursor {
			style = selectedStyleTUI
		}

		line := fmt.Sprintf("%s%s %s", cursor, checkbox, feature.name)
		b.WriteString(style.Render(line))
		b.WriteString("\n")

		if i == m.cursor {
			b.WriteString(infoStyleTUI.Render(fmt.Sprintf("    %s", feature.description)))
			b.WriteString("\n")
		}
	}

	b.WriteString("\n")

	// Summary
	enabledCount := m.countEnabledFeatures()
	if enabledCount > 0 {
		b.WriteString(successStyleTUI.Render(fmt.Sprintf("‚úì %d features enabled", enabledCount)))
	} else {
		b.WriteString(infoStyleTUI.Render("No advanced features enabled"))
	}

	b.WriteString("\n\n")
	b.WriteString(helpStyleTUI.Render("‚Üë/‚Üì: Navigate | Space/Enter: Toggle | s: Save & Back | Esc: Cancel"))

	return b.String()
}

func (m tuiModel) renderExport() string {
	var b strings.Builder

	selectedVMs := []tuiVMItem{}
	for _, item := range m.vms {
		if item.selected {
			selectedVMs = append(selectedVMs, item)
		}
	}

	// Modern header with gradient
	header := lipgloss.NewStyle().
		Bold(true).
		Foreground(primaryColor).
		Background(lightCharcoal).
		Width(80).
		Align(lipgloss.Center).
		Render("üöÄ Exporting Virtual Machines")
	b.WriteString(header)
	b.WriteString("\n\n")

	// Modern progress bar
	progressPercent := float64(m.currentExport) / float64(len(selectedVMs))
	progressBar := m.progressBar.ViewAs(progressPercent)

	progressInfo := lipgloss.NewStyle().
		Foreground(primaryColor).
		Bold(true).
		Render(fmt.Sprintf("Overall Progress: %d / %d VMs (%.0f%%)",
			m.currentExport,
			len(selectedVMs),
			progressPercent*100))

	b.WriteString(progressInfo)
	b.WriteString("\n")
	b.WriteString(progressBar)
	b.WriteString("\n\n")

	// Current VM info with real-time progress
	if m.currentExport < len(selectedVMs) {
		currentVM := selectedVMs[m.currentExport]

		// Build progress details
		var progressDetails strings.Builder
		progressDetails.WriteString(fmt.Sprintf("‚è≥ Currently Exporting: %s\n",
			lipgloss.NewStyle().Bold(true).Foreground(successColor).Render(currentVM.vm.Name)))
		progressDetails.WriteString(fmt.Sprintf("   Path: %s\n", currentVM.vm.Path))

		// Real-time transfer statistics
		if m.exportProgress.totalBytes > 0 {
			filePercent := float64(m.exportProgress.currentBytes) / float64(m.exportProgress.totalBytes) * 100
			progressDetails.WriteString(fmt.Sprintf("\n   üìä Transfer: %s / %s (%.1f%%)\n",
				formatBytes(m.exportProgress.currentBytes),
				formatBytes(m.exportProgress.totalBytes),
				filePercent))

			// File progress bar
			fileBar := m.progressBar.ViewAs(filePercent / 100.0)
			progressDetails.WriteString(fmt.Sprintf("   %s\n", fileBar))
		}

		// Current file being transferred
		if m.currentFileName != "" {
			progressDetails.WriteString(fmt.Sprintf("\n   üìÑ File: %s (%d/%d)\n",
				truncateString(m.currentFileName, 50),
				m.exportProgress.currentFileIdx+1,
				m.exportProgress.totalFiles))
		}

		// Transfer speed
		if m.exportProgress.speed > 0 {
			speedStyle := lipgloss.NewStyle().Foreground(tealInfo).Bold(true)
			progressDetails.WriteString(fmt.Sprintf("\n   ‚ö° Speed: %s\n",
				speedStyle.Render(fmt.Sprintf("%.2f MB/s", m.exportProgress.speed))))

			// Calculate ETA
			if m.exportProgress.totalBytes > m.exportProgress.currentBytes && m.exportProgress.speed > 0 {
				remainingBytes := m.exportProgress.totalBytes - m.exportProgress.currentBytes
				remainingMB := float64(remainingBytes) / (1024 * 1024)
				etaSeconds := remainingMB / m.exportProgress.speed
				etaDuration := time.Duration(etaSeconds * float64(time.Second))

				etaStyle := lipgloss.NewStyle().Foreground(amberYellow)
				progressDetails.WriteString(fmt.Sprintf("   ‚è±  ETA: %s\n",
					etaStyle.Render(formatDuration(etaDuration))))
			}
		}

		// Elapsed time
		if !m.exportProgress.startTime.IsZero() {
			elapsed := time.Since(m.exportProgress.startTime)
			progressDetails.WriteString(fmt.Sprintf("\n   ‚åõ Elapsed: %s",
				formatDuration(elapsed)))
		}

		currentBox := lipgloss.NewStyle().
			Border(lipgloss.RoundedBorder()).
			BorderForeground(primaryColor).
			Padding(1, 2).
			Render(progressDetails.String())
		b.WriteString(currentBox)
		b.WriteString("\n\n")
	}

	// VM list with modern icons and styling
	vmListBox := lipgloss.NewStyle().
		Border(lipgloss.RoundedBorder()).
		BorderForeground(mutedColor).
		Padding(1, 2).
		Width(78)

	var vmList strings.Builder
	for i, item := range selectedVMs {
		var status string
		var icon string
		var style lipgloss.Style

		if i < m.currentExport {
			status = "Completed"
			icon = "‚úÖ"
			style = lipgloss.NewStyle().Foreground(successColor)
		} else if i == m.currentExport {
			// Show spinner for current export
			status = m.spinner.View() + " Exporting..."
			icon = ""
			style = lipgloss.NewStyle().Foreground(primaryColor).Bold(true)
		} else {
			status = "Pending"
			icon = "‚è∏Ô∏è "
			style = lipgloss.NewStyle().Foreground(mutedColor)
		}

		vmLine := style.Render(fmt.Sprintf("%s %-45s %s",
			icon,
			truncateString(item.vm.Name, 45),
			status))
		vmList.WriteString(vmLine)
		vmList.WriteString("\n")
	}

	b.WriteString(vmListBox.Render(vmList.String()))
	b.WriteString("\n\n")

	// Bandwidth usage visualization
	if m.exportProgress.speed > 0 {
		bandwidthBox := m.renderBandwidthGraph()
		b.WriteString(bandwidthBox)
		b.WriteString("\n\n")
	}

	// Modern help with bubbles/help component
	helpView := m.helpModel.ShortHelpView([]key.Binding{m.keys.Quit})
	b.WriteString(lipgloss.NewStyle().
		Foreground(mutedColor).
		Italic(true).
		Render("üí° " + helpView + " | Export in progress..."))

	return b.String()
}

// renderBandwidthGraph creates a simple bar graph for bandwidth usage
func (m tuiModel) renderBandwidthGraph() string {
	maxBandwidth := 100.0 // Assume 100 MB/s max for visualization
	if m.featureConfig.enableBandwidthLimit && m.featureConfig.bandwidthLimitMBps > 0 {
		maxBandwidth = float64(m.featureConfig.bandwidthLimitMBps)
	}

	barWidth := 40
	currentBars := int(m.exportProgress.speed / maxBandwidth * float64(barWidth))
	if currentBars > barWidth {
		currentBars = barWidth
	}

	bars := strings.Repeat("‚ñà", currentBars)
	empty := strings.Repeat("‚ñë", barWidth-currentBars)

	bandwidthStr := fmt.Sprintf("üìà Bandwidth: %s%s %.2f/%.0f MB/s",
		lipgloss.NewStyle().Foreground(successGreen).Render(bars),
		lipgloss.NewStyle().Foreground(mutedGray).Render(empty),
		m.exportProgress.speed,
		maxBandwidth)

	return lipgloss.NewStyle().
		Foreground(tealInfo).
		Render(bandwidthStr)
}

// formatDuration formats a duration in a human-readable way
// min returns the minimum of two ints
func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}

// max returns the maximum of two ints
func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}

// getResponsiveWidth calculates responsive width based on terminal size
func (m tuiModel) getResponsiveWidth() int {
	if m.termWidth == 0 {
		return 80 // Default width
	}

	// Use 90% of terminal width, with min/max bounds
	width := min(max(m.termWidth-4, 40), 120)
	return width
}

// getBoxWidth returns width for lipgloss boxes based on terminal size
func (m tuiModel) getBoxWidth() int {
	width := m.getResponsiveWidth()
	return width - 4 // Account for padding and borders
}

// getHeaderWidth returns width for headers
func (m tuiModel) getHeaderWidth() int {
	return m.getResponsiveWidth()
}

// getColumnWidth calculates column width for multi-column layouts
func (m tuiModel) getColumnWidth(numColumns int) int {
	totalWidth := m.getResponsiveWidth()
	// Account for spacing between columns
	spacing := (numColumns - 1) * 2
	return (totalWidth - spacing) / numColumns
}

// truncateToWidth truncates a string to fit within a width
func truncateToWidth(s string, width int) string {
	if len(s) <= width {
		return s
	}
	if width < 3 {
		return s[:width]
	}
	return s[:width-3] + "..."
}

func formatDuration(d time.Duration) string {
	if d < time.Minute {
		return fmt.Sprintf("%.0fs", d.Seconds())
	}
	if d < time.Hour {
		minutes := int(d.Minutes())
		seconds := int(d.Seconds()) % 60
		return fmt.Sprintf("%dm %ds", minutes, seconds)
	}
	hours := int(d.Hours())
	minutes := int(d.Minutes()) % 60
	return fmt.Sprintf("%dh %dm", hours, minutes)
}

func (m tuiModel) renderCloudUpload() string {
	var b strings.Builder

	boxWidth := m.getBoxWidth()
	headerWidth := m.getHeaderWidth()

	// Header
	header := lipgloss.NewStyle().
		Bold(true).
		Foreground(primaryColor).
		Background(lightCharcoal).
		Width(headerWidth).
		Align(lipgloss.Center).
		Render("‚òÅÔ∏è  Uploading to Cloud")
	b.WriteString(header)
	b.WriteString("\n\n")

	if m.cloudConfig == nil {
		return errorStyleTUI.Render("No cloud configuration found")
	}

	// Cloud provider info
	providerBox := lipgloss.NewStyle().
		Border(lipgloss.RoundedBorder()).
		BorderForeground(tealInfo).
		Padding(1, 2).
		Width(boxWidth)

	var providerInfo strings.Builder
	providerInfo.WriteString(lipgloss.NewStyle().
		Foreground(tealInfo).
		Bold(true).
		Render(fmt.Sprintf("üì¶ Provider: %s", m.cloudConfig.provider)))
	providerInfo.WriteString("\n")
	providerInfo.WriteString(lipgloss.NewStyle().Foreground(textColor).Render(
		fmt.Sprintf("   Bucket: %s", m.cloudConfig.bucket)))
	if m.cloudConfig.prefix != "" {
		providerInfo.WriteString("\n")
		providerInfo.WriteString(lipgloss.NewStyle().Foreground(textColor).Render(
			fmt.Sprintf("   Prefix: %s", m.cloudConfig.prefix)))
	}

	b.WriteString(providerBox.Render(providerInfo.String()))
	b.WriteString("\n\n")

	// Upload progress
	progressBox := lipgloss.NewStyle().
		Border(lipgloss.RoundedBorder()).
		BorderForeground(primaryColor).
		Padding(1, 2).
		Width(boxWidth)

	var progress strings.Builder

	if m.exportProgress.totalBytes > 0 {
		uploadPercent := float64(m.exportProgress.currentBytes) / float64(m.exportProgress.totalBytes) * 100
		progress.WriteString(lipgloss.NewStyle().
			Foreground(primaryColor).
			Bold(true).
			Render(fmt.Sprintf("‚¨ÜÔ∏è  Upload Progress: %.1f%%", uploadPercent)))
		progress.WriteString("\n\n")

		// Progress bar (animated with gradient)
		barWidth := min(boxWidth-10, 60)
		animatedBar := renderAnimatedProgressBar(uploadPercent, barWidth)
		progress.WriteString(animatedBar)
		progress.WriteString(" ")
		progress.WriteString(progressLabelStyleTUI.Render(fmt.Sprintf("%.1f%%", uploadPercent)))
		progress.WriteString("\n\n")

		// Transfer stats
		progress.WriteString(lipgloss.NewStyle().Foreground(textColor).Render(
			fmt.Sprintf("üìä %s / %s",
				formatBytes(m.exportProgress.currentBytes),
				formatBytes(m.exportProgress.totalBytes))))
		progress.WriteString("\n")

		// Upload speed
		if m.exportProgress.speed > 0 {
			progress.WriteString(lipgloss.NewStyle().Foreground(tealInfo).Render(
				fmt.Sprintf("‚ö° %.2f MB/s", m.exportProgress.speed)))
			progress.WriteString("\n")

			// ETA
			if m.exportProgress.totalBytes > m.exportProgress.currentBytes {
				remainingBytes := m.exportProgress.totalBytes - m.exportProgress.currentBytes
				remainingMB := float64(remainingBytes) / (1024 * 1024)
				etaSeconds := remainingMB / m.exportProgress.speed
				etaDuration := time.Duration(etaSeconds * float64(time.Second))

				progress.WriteString(lipgloss.NewStyle().Foreground(amberYellow).Render(
					fmt.Sprintf("‚è±  ETA: %s", formatDuration(etaDuration))))
			}
		}
	} else {
		// Animated spinner for preparing files
		frames := getDotSpinnerFrames()
		spinnerChar := frames[m.animFrame%len(frames)]
		progress.WriteString(spinnerProcessingStyleTUI.Render(spinnerChar))
		progress.WriteString(" ")
		progress.WriteString(lipgloss.NewStyle().Foreground(amberYellow).Render("Preparing files for upload..."))
	}

	b.WriteString(progressBox.Render(progress.String()))
	b.WriteString("\n\n")

	// Current file
	if m.currentFileName != "" {
		fileBox := lipgloss.NewStyle().
			Border(lipgloss.RoundedBorder()).
			BorderForeground(mutedGray).
			Padding(0, 1)

		b.WriteString(fileBox.Render(
			lipgloss.NewStyle().Foreground(mutedGray).Render(
				fmt.Sprintf("üìÑ %s (%d/%d)",
					truncateString(m.currentFileName, 60),
					m.exportProgress.currentFileIdx+1,
					m.exportProgress.totalFiles))))
		b.WriteString("\n\n")
	}

	// Help
	helpView := m.helpModel.ShortHelpView([]key.Binding{m.keys.Quit})
	b.WriteString(lipgloss.NewStyle().
		Foreground(mutedColor).
		Italic(true).
		Render("üí° " + helpView + " | Upload in progress..."))

	return b.String()
}

func (m tuiModel) renderDone() string {
	return successStyleTUI.Render("‚úÖ Export complete!\n\nPress q to quit")
}

func (m tuiModel) renderHelp() string {
	help := `‚å®Ô∏è  Keyboard Shortcuts

Navigation:
  ‚Üë/k       Move up
  ‚Üì/j       Move down
  Space     Toggle checkbox [ ] / [x] - Multi-select VMs
  Enter     Continue to confirmation

Multi-Selection:
  a         Select all visible VMs [x]
  n         Clear all selections [ ]
  A         Bulk select by regex pattern
  1-7       Quick filters (select VMs matching criteria)

Filters:
  1         Powered ON
  2         Powered OFF
  3         Linux VMs
  4         Windows VMs
  5         High CPU (8+)
  6         High Memory (16GB+)
  7         Large Storage (500GB+)

Actions:
  i         Show VM details
  x         Quick actions menu (power, snapshot, export)
  b         Bulk operations (perform actions on multiple VMs)
  C         Compare VMs side-by-side (select 2-4 VMs)
  m         Bookmarks & saved filters
  u         Cloud upload (S3/Azure/GCS/SFTP)
  t         Export templates
  f         Advanced features
  s         Cycle sort
  c         Clear filters

Views:
  v         Toggle split-screen
  ]         Folder tree view
  D         Statistics dashboard
  M         Performance metrics
  H         Export history
  L         Live logs viewer
  Q         Queue manager

Other:
  h/?       Toggle help
  q         Quit
`
	return panelStyleTUI.Render(help)
}

// Helper methods
func (m *tuiModel) getVisibleVMs() []tuiVMItem {
	if m.filteredVMs != nil {
		return m.filteredVMs
	}
	return m.vms
}

func (m tuiModel) countSelected() int {
	count := 0
	for _, item := range m.vms {
		if item.selected {
			count++
		}
	}
	return count
}

// getSelectedVMs returns a list of selected VMs
func (m tuiModel) getSelectedVMs() []tuiVMItem {
	selectedVMs := make([]tuiVMItem, 0)
	for _, item := range m.vms {
		if item.selected {
			selectedVMs = append(selectedVMs, item)
		}
	}
	return selectedVMs
}

// buildExportQueue creates export queue from selected VMs
func (m tuiModel) buildExportQueue() []queuedExport {
	queue := make([]queuedExport, 0)
	for _, item := range m.vms {
		if item.selected {
			queue = append(queue, queuedExport{
				vm:       item.vm,
				priority: 2, // Normal priority by default
				status:   "pending",
				eta:      0,
			})
		}
	}
	return queue
}

// handleQueueKeys handles keyboard input in queue management phase
func (m tuiModel) handleQueueKeys(msg tea.KeyMsg) (tea.Model, tea.Cmd) {
	switch msg.String() {
	case "ctrl+c", "esc":
		// Return to selection
		m.phase = "select"
		m.showQueueEditor = false
		return m, nil

	case "up", "k":
		if m.queueCursor > 0 {
			m.queueCursor--
		}

	case "down", "j":
		if m.queueCursor < len(m.exportQueue)-1 {
			m.queueCursor++
		}

	case "K", "shift+up":
		// Move current item up in queue
		if m.queueCursor > 0 {
			m.exportQueue[m.queueCursor], m.exportQueue[m.queueCursor-1] =
				m.exportQueue[m.queueCursor-1], m.exportQueue[m.queueCursor]
			m.queueCursor--
		}

	case "J", "shift+down":
		// Move current item down in queue
		if m.queueCursor < len(m.exportQueue)-1 {
			m.exportQueue[m.queueCursor], m.exportQueue[m.queueCursor+1] =
				m.exportQueue[m.queueCursor+1], m.exportQueue[m.queueCursor]
			m.queueCursor++
		}

	case "p", "P":
		// Cycle priority: normal -> high -> low -> normal
		current := &m.exportQueue[m.queueCursor]
		switch current.priority {
		case 1: // high -> low
			current.priority = 3
		case 2: // normal -> high
			current.priority = 1
		case 3: // low -> normal
			current.priority = 2
		}

	case "enter":
		// Confirm and proceed to export
		m.phase = "confirm"
		m.showQueueEditor = false
		return m, nil
	}

	return m, nil
}

// renderQueue renders the export queue management interface
func (m tuiModel) renderQueue() string {
	var b strings.Builder

	// Header
	header := lipgloss.NewStyle().
		Foreground(tealInfo).
		Background(darkBg).
		Bold(true).
		Padding(0, 2).
		Border(lipgloss.DoubleBorder()).
		BorderForeground(deepOrange).
		Width(m.getResponsiveWidth() - 4).
		Render("‚ïî‚ïê‚ïê‚ïê EXPORT QUEUE MANAGER ‚ïê‚ïê‚ïê‚ïó  Reorder & Prioritize Exports")

	b.WriteString(header)
	b.WriteString("\n\n")

	// Instructions
	instructions := lipgloss.NewStyle().
		Foreground(lipgloss.Color("#9CA3AF")).
		Italic(true).
		Render("K/Shift+‚Üë: Move Up  |  J/Shift+‚Üì: Move Down  |  P: Change Priority  |  Enter: Confirm  |  Esc: Cancel")

	b.WriteString(instructions)
	b.WriteString("\n\n")

	// Queue header
	queueHeader := lipgloss.NewStyle().
		Foreground(tealInfo).
		Bold(true).
		Render(fmt.Sprintf("üìã Export Queue (%d VMs)", len(m.exportQueue)))

	b.WriteString(queueHeader)
	b.WriteString("\n")
	b.WriteString(strings.Repeat("‚îÄ", m.getResponsiveWidth()-4))
	b.WriteString("\n\n")

	// Queue items
	for i, item := range m.exportQueue {
		cursor := "  "
		if i == m.queueCursor {
			cursor = "‚ùØ "
		}

		// Priority indicator
		priorityIndicator := ""
		priorityColor := lipgloss.Color("#9CA3AF")
		switch item.priority {
		case 1:
			priorityIndicator = "[HIGH]"
			priorityColor = warmRed
		case 2:
			priorityIndicator = "[NORM]"
			priorityColor = lipgloss.Color("#60A5FA")
		case 3:
			priorityIndicator = "[LOW]"
			priorityColor = lipgloss.Color("#6B7280")
		}

		priority := lipgloss.NewStyle().
			Foreground(priorityColor).
			Bold(true).
			Width(8).
			Render(priorityIndicator)

		// Position indicator
		position := lipgloss.NewStyle().
			Foreground(lipgloss.Color("#9CA3AF")).
			Width(5).
			Render(fmt.Sprintf("#%d", i+1))

		// VM name
		name := item.vm.Name
		maxNameLen := m.getResponsiveWidth() - 30
		if len(name) > maxNameLen {
			name = name[:maxNameLen-3] + "..."
		}

		nameStyle := lipgloss.NewStyle()
		if i == m.queueCursor {
			nameStyle = nameStyle.Foreground(tealInfo).Bold(true)
		}

		vmName := nameStyle.Render(name)

		// VM specs (size indicator)
		specs := lipgloss.NewStyle().
			Foreground(lipgloss.Color("#6B7280")).
			Render(fmt.Sprintf("%.1f GB", float64(item.vm.Storage)/(1024*1024*1024)))

		line := fmt.Sprintf("%s%s %s  %s  %s", cursor, position, priority, vmName, specs)
		b.WriteString(line)
		b.WriteString("\n")
	}

	b.WriteString("\n")

	// Summary
	highCount := 0
	normalCount := 0
	lowCount := 0
	for _, item := range m.exportQueue {
		switch item.priority {
		case 1:
			highCount++
		case 2:
			normalCount++
		case 3:
			lowCount++
		}
	}

	summary := lipgloss.NewStyle().
		Foreground(lipgloss.Color("#9CA3AF")).
		Border(lipgloss.RoundedBorder()).
		BorderForeground(tealInfo).
		Padding(0, 2).
		Render(fmt.Sprintf("Summary: %d High  |  %d Normal  |  %d Low  |  Total: %d VMs",
			highCount, normalCount, lowCount, len(m.exportQueue)))

	b.WriteString(summary)
	b.WriteString("\n\n")

	// Footer help
	footer := lipgloss.NewStyle().
		Foreground(successGreen).
		Bold(true).
		Render("Press Enter to proceed with export in this order")

	b.WriteString(footer)

	return b.String()
}

// loadHistoryEntries loads export history from disk
func (m *tuiModel) loadHistoryEntries() error {
	historyFile, err := GetDefaultHistoryFile()
	if err != nil {
		return fmt.Errorf("get history file: %w", err)
	}

	history := NewExportHistory(historyFile, m.log)
	entries, err := history.GetHistory()
	if err != nil {
		// If file doesn't exist, that's OK - just no history yet
		if os.IsNotExist(err) {
			m.historyEntries = []ExportHistoryEntry{}
			return nil
		}
		return fmt.Errorf("load history: %w", err)
	}

	m.historyEntries = entries
	return nil
}

// getFilteredHistory returns history entries matching current filters
func (m tuiModel) getFilteredHistory() []ExportHistoryEntry {
	filtered := make([]ExportHistoryEntry, 0)
	now := time.Now()

	for _, entry := range m.historyEntries {
		// Apply success/failure filter
		if m.historyFilter == "success" && !entry.Success {
			continue
		}
		if m.historyFilter == "failed" && entry.Success {
			continue
		}

		// Apply date filter
		switch m.historyDateFilter {
		case "today":
			if entry.Timestamp.Before(now.Add(-24 * time.Hour)) {
				continue
			}
		case "week":
			if entry.Timestamp.Before(now.Add(-7 * 24 * time.Hour)) {
				continue
			}
		case "month":
			if entry.Timestamp.Before(now.Add(-30 * 24 * time.Hour)) {
				continue
			}
		}

		// Apply search query
		if m.historySearchQuery != "" {
			query := strings.ToLower(m.historySearchQuery)
			if !strings.Contains(strings.ToLower(entry.VMName), query) &&
				!strings.Contains(strings.ToLower(entry.VMPath), query) {
				continue
			}
		}

		// Apply provider filter
		if m.historyProviderFilter != "all" && entry.Provider != m.historyProviderFilter {
			continue
		}

		filtered = append(filtered, entry)
	}

	return filtered
}

// handleHistoryKeys handles keyboard input in history view
func (m tuiModel) handleHistoryKeys(msg tea.KeyMsg) (tea.Model, tea.Cmd) {
	entries := m.getFilteredHistory()

	switch msg.String() {
	case "ctrl+c", "q", "esc":
		// Return to selection
		m.phase = "select"
		return m, nil

	case "up", "k":
		if m.historyCursor > 0 {
			m.historyCursor--
		}

	case "down", "j":
		if m.historyCursor < len(entries)-1 {
			m.historyCursor++
		}

	case "f", "F":
		// Cycle through filters
		switch m.historyFilter {
		case "all":
			m.historyFilter = "success"
		case "success":
			m.historyFilter = "failed"
		case "failed":
			m.historyFilter = "all"
		}
		m.historyCursor = 0

	case "d", "D":
		// Cycle through date filters
		switch m.historyDateFilter {
		case "all":
			m.historyDateFilter = "today"
		case "today":
			m.historyDateFilter = "week"
		case "week":
			m.historyDateFilter = "month"
		case "month":
			m.historyDateFilter = "all"
		}
		m.historyCursor = 0

	case "r", "R":
		// Refresh history
		if err := m.loadHistoryEntries(); err != nil {
			m.message = fmt.Sprintf("Failed to reload history: %v", err)
		}
	}

	return m, nil
}

// renderHistory renders the export history view
func (m tuiModel) renderHistory() string {
	var b strings.Builder

	// Header
	header := lipgloss.NewStyle().
		Foreground(tealInfo).
		Background(darkBg).
		Bold(true).
		Padding(0, 2).
		Border(lipgloss.DoubleBorder()).
		BorderForeground(deepOrange).
		Width(m.getResponsiveWidth() - 4).
		Render("‚ïî‚ïê‚ïê‚ïê EXPORT HISTORY ‚ïê‚ïê‚ïê‚ïó  View Past Exports")

	b.WriteString(header)
	b.WriteString("\n\n")

	// Active filters indicator
	filterParts := []string{}
	if m.historyFilter != "all" {
		filterParts = append(filterParts, fmt.Sprintf("Status: %s", m.historyFilter))
	}
	if m.historyDateFilter != "all" {
		filterParts = append(filterParts, fmt.Sprintf("Time: %s", m.historyDateFilter))
	}
	if m.historySearchQuery != "" {
		filterParts = append(filterParts, fmt.Sprintf("Search: %s", m.historySearchQuery))
	}

	if len(filterParts) > 0 {
		filters := lipgloss.NewStyle().
			Foreground(amberYellow).
			Italic(true).
			Render("Active Filters: " + strings.Join(filterParts, " | "))
		b.WriteString(filters)
		b.WriteString("\n\n")
	}

	// Instructions
	instructions := lipgloss.NewStyle().
		Foreground(lipgloss.Color("#9CA3AF")).
		Italic(true).
		Render("F: Filter Status  |  D: Date Range  |  R: Refresh  |  Esc: Back")

	b.WriteString(instructions)
	b.WriteString("\n\n")

	// Get filtered entries
	entries := m.getFilteredHistory()

	if len(entries) == 0 {
		noHistory := lipgloss.NewStyle().
			Foreground(lipgloss.Color("#9CA3AF")).
			Italic(true).
			Render("No export history found")
		b.WriteString(noHistory)
		return b.String()
	}

	// Summary stats
	totalExports := len(entries)
	successCount := 0
	failedCount := 0
	var totalSize int64
	var totalDuration time.Duration

	for _, entry := range entries {
		if entry.Success {
			successCount++
		} else {
			failedCount++
		}
		totalSize += entry.TotalSize
		totalDuration += entry.Duration
	}

	summary := lipgloss.NewStyle().
		Foreground(tealInfo).
		Bold(true).
		Render(fmt.Sprintf("üìä %d Total | ‚úì %d Success | ‚úó %d Failed | üíæ %.2f GB | ‚è± %s avg",
			totalExports, successCount, failedCount,
			float64(totalSize)/(1024*1024*1024),
			(totalDuration / time.Duration(totalExports)).Round(time.Second)))

	b.WriteString(summary)
	b.WriteString("\n")
	b.WriteString(strings.Repeat("‚îÄ", m.getResponsiveWidth()-4))
	b.WriteString("\n\n")

	// History entries (show last 15)
	maxVisible := 15
	start := 0
	if len(entries) > maxVisible {
		start = len(entries) - maxVisible
		if m.historyCursor < start {
			start = m.historyCursor
		}
		if m.historyCursor >= start+maxVisible {
			start = m.historyCursor - maxVisible + 1
		}
	}

	end := start + maxVisible
	if end > len(entries) {
		end = len(entries)
	}

	// Reverse order (most recent first)
	for i := end - 1; i >= start; i-- {
		entry := entries[i]

		cursor := "  "
		if i == m.historyCursor {
			cursor = "‚ùØ "
		}

		// Status indicator
		statusIcon := "‚úì"
		statusColor := successGreen
		if !entry.Success {
			statusIcon = "‚úó"
			statusColor = warmRed
		}

		status := lipgloss.NewStyle().
			Foreground(statusColor).
			Bold(true).
			Width(3).
			Render(statusIcon)

		// Timestamp
		timestamp := entry.Timestamp.Format("01/02 15:04")
		timeStyle := lipgloss.NewStyle().
			Foreground(lipgloss.Color("#9CA3AF")).
			Width(12)
		timeStr := timeStyle.Render(timestamp)

		// VM name
		name := entry.VMName
		maxNameLen := m.getResponsiveWidth() - 50
		if len(name) > maxNameLen {
			name = name[:maxNameLen-3] + "..."
		}

		nameStyle := lipgloss.NewStyle()
		if i == m.historyCursor {
			nameStyle = nameStyle.Foreground(tealInfo).Bold(true)
		}
		vmName := nameStyle.Render(name)

		// Format & size
		details := lipgloss.NewStyle().
			Foreground(lipgloss.Color("#6B7280")).
			Render(fmt.Sprintf("%s | %.1f GB | %s",
				entry.Format,
				float64(entry.TotalSize)/(1024*1024*1024),
				entry.Duration.Round(time.Second)))

		line := fmt.Sprintf("%s%s %s  %s  %s", cursor, status, timeStr, vmName, details)
		b.WriteString(line)
		b.WriteString("\n")
	}

	// Show details of selected entry if cursor is valid
	if m.historyCursor < len(entries) && m.historyCursor >= 0 {
		b.WriteString("\n")
		b.WriteString(strings.Repeat("‚îÄ", m.getResponsiveWidth()-4))
		b.WriteString("\n")

		selectedEntry := entries[m.historyCursor]
		b.WriteString(m.renderHistoryDetails(selectedEntry))
	}

	return b.String()
}

// renderHistoryDetails renders detailed information about a history entry
func (m tuiModel) renderHistoryDetails(entry ExportHistoryEntry) string {
	var b strings.Builder

	detailsTitle := lipgloss.NewStyle().
		Foreground(tealInfo).
		Bold(true).
		Render("üìù Export Details")

	b.WriteString(detailsTitle)
	b.WriteString("\n\n")

	details := []struct {
		label string
		value string
		color lipgloss.Color
	}{
		{"VM Name", entry.VMName, tealInfo},
		{"VM Path", entry.VMPath, lipgloss.Color("#6B7280")},
		{"Provider", entry.Provider, lipgloss.Color("#9CA3AF")},
		{"Format", entry.Format, lipgloss.Color("#60A5FA")},
		{"Size", fmt.Sprintf("%.2f GB", float64(entry.TotalSize)/(1024*1024*1024)), lipgloss.Color("#34D399")},
		{"Duration", entry.Duration.Round(time.Second).String(), lipgloss.Color("#F59E0B")},
		{"Files", fmt.Sprintf("%d", entry.FilesCount), lipgloss.Color("#9CA3AF")},
		{"Timestamp", entry.Timestamp.Format("2006-01-02 15:04:05"), lipgloss.Color("#6B7280")},
		{"Output Dir", entry.OutputDir, lipgloss.Color("#6B7280")},
	}

	for _, detail := range details {
		label := lipgloss.NewStyle().
			Foreground(lipgloss.Color("#9CA3AF")).
			Width(14).
			Render(detail.label + ":")

		value := lipgloss.NewStyle().
			Foreground(detail.color).
			Render(detail.value)

		b.WriteString(label + " " + value)
		b.WriteString("\n")
	}

	// Show error if failed
	if !entry.Success && entry.ErrorMessage != "" {
		b.WriteString("\n")
		errorLabel := lipgloss.NewStyle().
			Foreground(warmRed).
			Bold(true).
			Render("Error:")

		errorMsg := lipgloss.NewStyle().
			Foreground(warmRed).
			Render(" " + entry.ErrorMessage)

		b.WriteString(errorLabel + errorMsg)
	}

	return b.String()
}

func (m *tuiModel) applyFiltersAndSort() {
	filtered := make([]tuiVMItem, 0, len(m.vms))

	for _, item := range m.vms {
		// Apply search
		if m.searchQuery != "" {
			query := strings.ToLower(m.searchQuery)
			if !strings.Contains(strings.ToLower(item.vm.Name), query) &&
				!strings.Contains(strings.ToLower(item.vm.Path), query) {
				continue
			}
		}

		// Apply power filter
		if m.filterPower == "on" && item.vm.PowerState != "poweredOn" {
			continue
		}
		if m.filterPower == "off" && item.vm.PowerState == "poweredOn" {
			continue
		}

		// Apply OS filter
		if m.filterOS != "" {
			if !strings.Contains(strings.ToLower(item.vm.GuestOS), strings.ToLower(m.filterOS)) {
				continue
			}
		}

		// Apply quick filters
		if m.quickFilter != "" {
			switch m.quickFilter {
			case "highcpu":
				if item.vm.NumCPU < 8 {
					continue
				}
			case "highmem":
				if item.vm.MemoryMB < 16*1024 {
					continue
				}
			case "largestorage":
				if item.vm.Storage < 500*1024*1024*1024 {
					continue
				}
			}
		}

		filtered = append(filtered, item)
	}

	// Sort
	switch m.sortMode {
	case "cpu":
		sort.Slice(filtered, func(i, j int) bool {
			return filtered[i].vm.NumCPU > filtered[j].vm.NumCPU
		})
	case "memory":
		sort.Slice(filtered, func(i, j int) bool {
			return filtered[i].vm.MemoryMB > filtered[j].vm.MemoryMB
		})
	case "storage":
		sort.Slice(filtered, func(i, j int) bool {
			return filtered[i].vm.Storage > filtered[j].vm.Storage
		})
	case "power":
		sort.Slice(filtered, func(i, j int) bool {
			if filtered[i].vm.PowerState == "poweredOn" && filtered[j].vm.PowerState != "poweredOn" {
				return true
			}
			return false
		})
	default: // name
		sort.Slice(filtered, func(i, j int) bool {
			return strings.ToLower(filtered[i].vm.Name) < strings.ToLower(filtered[j].vm.Name)
		})
	}

	m.filteredVMs = filtered

	if len(filtered) > 0 && m.cursor >= len(filtered) {
		m.cursor = len(filtered) - 1
	}
	if m.cursor < 0 {
		m.cursor = 0
	}
}

func (m *tuiModel) cycleSortMode() {
	modes := []string{"name", "cpu", "memory", "storage", "power"}
	for i, mode := range modes {
		if m.sortMode == mode {
			m.sortMode = modes[(i+1)%len(modes)]
			return
		}
	}
	m.sortMode = "name"
}

func (m *tuiModel) applyQuickFilter(key string) {
	m.searchQuery = ""
	m.filterPower = ""
	m.filterOS = ""
	m.quickFilter = ""

	switch key {
	case "1":
		m.filterPower = "on"
		m.message = "Filter: Powered ON"
	case "2":
		m.filterPower = "off"
		m.message = "Filter: Powered OFF"
	case "3":
		m.filterOS = "linux"
		m.message = "Filter: Linux"
	case "4":
		m.filterOS = "windows"
		m.message = "Filter: Windows"
	case "5":
		m.quickFilter = "highcpu"
		m.message = "Filter: High CPU (8+)"
	case "6":
		m.quickFilter = "highmem"
		m.message = "Filter: High Memory (16GB+)"
	case "7":
		m.quickFilter = "largestorage"
		m.message = "Filter: Large Storage (500GB+)"
	case "0":
		m.message = "Filters cleared"
	}

	m.applyFiltersAndSort()
}

func (m tuiModel) runValidation() tea.Cmd {
	return func() tea.Msg {
		// Get selected VMs
		selectedVMs := []vsphere.VMInfo{}
		for _, item := range m.vms {
			if item.selected {
				selectedVMs = append(selectedVMs, item.vm)
			}
		}

		if len(selectedVMs) == 0 {
			return validationCompleteMsg{
				err: fmt.Errorf("no VMs selected"),
			}
		}

		// Calculate total storage requirement
		var totalStorage int64
		for _, vm := range selectedVMs {
			totalStorage += vm.Storage
		}

		// Run pre-export validation
		validator := NewPreExportValidator(m.log)

		// For now, validate against the first VM (we'll aggregate later)
		report := validator.ValidateExport(m.ctx, selectedVMs[0], m.outputDir, totalStorage)

		return validationCompleteMsg{
			report: report,
			err:    nil,
		}
	}
}

func (m tuiModel) exportNext() tea.Cmd {
	return func() tea.Msg {
		// Find next selected VM
		exportIndex := 0
		for _, item := range m.vms {
			if item.selected {
				if exportIndex == m.currentExport {
					vmName := item.vm.Name
					vmPath := item.vm.Path

					// Build export options
					opts := &vsphere.ExportOptions{
						OutputPath:         m.outputDir,
						Format:             "ovf", // Default to OVF
						Compress:           false,
						ValidateChecksum:   false,
						ParallelDownloads:  1,
						ShowIndividualProgress: false, // Disable terminal progress (we're in TUI mode)
						ShowOverallProgress:    false, // Disable terminal progress (we're in TUI mode)
					}

					// Apply selected template if available
					if m.selectedTemplate != nil {
						opts.Format = m.selectedTemplate.format
						opts.Compress = m.selectedTemplate.compress
						opts.ValidateChecksum = m.selectedTemplate.verify
						if m.selectedTemplate.format == "ova" {
							opts.CleanupOVF = true
						}
					}

					// Apply feature configuration
					if m.featureConfig.enableBandwidthLimit {
						// Note: bandwidth limiting would need to be implemented in the ExportOVF function
						m.log.Info("Bandwidth limit: %d MB/s", m.featureConfig.bandwidthLimitMBps)
					}

					// Create cancellable context for this export
					exportCtx, cancelFunc := context.WithCancel(m.ctx)

					// Create progress callback channel
					progressChan := make(chan exportProgressMsg, 100)
					doneChan := make(chan exportDoneMsg, 1)

					// Set up progress callback
					opts.ProgressCallback = func(current, total int64, fileName string, fileIndex, totalFiles int) {
						// Send progress update (non-blocking)
						select {
						case progressChan <- exportProgressMsg{
							vmName:         vmName,
							currentBytes:   current,
							totalBytes:     total,
							currentFileIdx: fileIndex,
							totalFiles:     totalFiles,
							fileName:       fileName,
							progressChan:   progressChan,
							doneChan:       doneChan,
						}:
						default:
							// Skip if channel is full (throttle updates)
						}
					}

					// Create the export command that will run in background
					actualExportCmd := func() tea.Msg {
						// Start export in background
						go func() {
							result, err := m.client.ExportOVF(exportCtx, vmPath, *opts)
							if err != nil {
								m.log.Error("Export failed for %s: %v", vmName, err)
								doneChan <- exportDoneMsg{vmName: vmName, err: err}
							} else {
								m.log.Info("Export completed for %s: %s", vmName, result.OVFPath)
								doneChan <- exportDoneMsg{vmName: vmName, err: nil}
							}
							close(progressChan)
							close(doneChan)
						}()

						// Return first progress/done message
						return m.waitForExport(progressChan, doneChan)
					}

					// Return message to set cancel function, then run export
					return exportStartMsg{
						cancelFunc: cancelFunc,
						exportCmd:  actualExportCmd,
					}
				}
				exportIndex++
			}
		}
		return exportDoneMsg{vmName: "", err: fmt.Errorf("no more VMs to export")}
	}
}

// waitForExport returns the first message from either progress or done channels
func (m tuiModel) waitForExport(progressChan <-chan exportProgressMsg, doneChan <-chan exportDoneMsg) tea.Msg {
	select {
	case msg, ok := <-progressChan:
		if ok {
			return msg
		}
		// If progress channel is closed, wait for done
		return <-doneChan
	case msg := <-doneChan:
		return msg
	}
}

// Utility functions
func truncateString(s string, max int) string {
	if len(s) <= max {
		return s
	}
	return s[:max-3] + "..."
}

func formatBytesCompact(bytes int64) string {
	const unit = 1024
	if bytes < unit {
		return fmt.Sprintf("%dB", bytes)
	}
	if bytes < unit*unit {
		return fmt.Sprintf("%.0fK", float64(bytes)/unit)
	}
	if bytes < unit*unit*unit {
		return fmt.Sprintf("%.0fM", float64(bytes)/(unit*unit))
	}
	if bytes < unit*unit*unit*unit {
		return fmt.Sprintf("%.1fG", float64(bytes)/(unit*unit*unit))
	}
	return fmt.Sprintf("%.1fT", float64(bytes)/(unit*unit*unit*unit))
}

func getDiskSpace(path string) int64 {
	var stat syscall.Statfs_t
	if err := syscall.Statfs(path, &stat); err != nil {
		return 0
	}
	return int64(stat.Bavail) * int64(stat.Bsize)
}

func matchVMPattern(vmName, pattern string) bool {
	vmLower := strings.ToLower(vmName)
	patternLower := strings.ToLower(pattern)

	if strings.HasPrefix(patternLower, "^") {
		patternLower = strings.TrimPrefix(patternLower, "^")
		return strings.HasPrefix(vmLower, patternLower)
	}

	if strings.HasSuffix(patternLower, "$") {
		patternLower = strings.TrimSuffix(patternLower, "$")
		return strings.HasSuffix(vmLower, patternLower)
	}

	return strings.Contains(vmLower, patternLower)
}

// addLogEntry adds a new log entry to the logs viewer
func (m *tuiModel) addLogEntry(level, message, vmName string) {
	entry := logEntry{
		timestamp: time.Now(),
		level:     level,
		message:   message,
		vmName:    vmName,
	}

	m.logEntries = append(m.logEntries, entry)

	// Limit log entries to maxLogEntries
	if len(m.logEntries) > m.maxLogEntries {
		m.logEntries = m.logEntries[len(m.logEntries)-m.maxLogEntries:]
	}

	// Auto-scroll to bottom if enabled
	if m.autoScrollLogs {
		filtered := m.getFilteredLogs()
		if len(filtered) > 0 {
			m.logCursor = len(filtered) - 1
		}
	}
}

// getFilteredLogs returns logs filtered by level and search query
func (m tuiModel) getFilteredLogs() []logEntry {
	filtered := make([]logEntry, 0)

	for _, entry := range m.logEntries {
		// Apply level filter
		if m.logLevelFilter != "all" {
			if strings.ToLower(entry.level) != strings.ToLower(m.logLevelFilter) {
				continue
			}
		}

		// Apply search query
		if m.logSearchQuery != "" {
			query := strings.ToLower(m.logSearchQuery)
			if !strings.Contains(strings.ToLower(entry.message), query) &&
				!strings.Contains(strings.ToLower(entry.vmName), query) {
				continue
			}
		}

		filtered = append(filtered, entry)
	}

	return filtered
}

// handleLogsKeys handles keyboard input in logs view
func (m tuiModel) handleLogsKeys(msg tea.KeyMsg) (tea.Model, tea.Cmd) {
	entries := m.getFilteredLogs()

	switch msg.String() {
	case "ctrl+c", "q", "esc":
		// Return to selection or hide logs panel
		if m.phase == "export" {
			m.showLogsPanel = false
		} else {
			m.phase = "select"
		}
		return m, nil

	case "up", "k":
		if m.logCursor > 0 {
			m.logCursor--
			m.autoScrollLogs = false
		}

	case "down", "j":
		if m.logCursor < len(entries)-1 {
			m.logCursor++
		}

	case "g":
		m.logCursor = 0
		m.autoScrollLogs = false

	case "G":
		if len(entries) > 0 {
			m.logCursor = len(entries) - 1
		}
		m.autoScrollLogs = true

	case "l", "L":
		switch m.logLevelFilter {
		case "all":
			m.logLevelFilter = "info"
		case "info":
			m.logLevelFilter = "warn"
		case "warn":
			m.logLevelFilter = "error"
		case "error":
			m.logLevelFilter = "debug"
		case "debug":
			m.logLevelFilter = "all"
		}
		m.logCursor = 0

	case "a", "A":
		m.autoScrollLogs = !m.autoScrollLogs
		if m.autoScrollLogs && len(entries) > 0 {
			m.logCursor = len(entries) - 1
		}

	case "c", "C":
		m.logEntries = []logEntry{}
		m.logCursor = 0
	}

	return m, nil
}

// renderLogs renders the live logs viewer
func (m tuiModel) renderLogs() string {
	var b strings.Builder

	header := lipgloss.NewStyle().
		Foreground(tealInfo).
		Background(darkBg).
		Bold(true).
		Padding(0, 2).
		Border(lipgloss.DoubleBorder()).
		BorderForeground(deepOrange).
		Width(m.getResponsiveWidth() - 4).
		Render("‚ïî‚ïê‚ïê‚ïê LIVE LOGS VIEWER ‚ïê‚ïê‚ïê‚ïó  Real-time Export Logs")

	b.WriteString(header)
	b.WriteString("\n\n")

	filterParts := []string{}
	if m.logLevelFilter != "all" {
		filterParts = append(filterParts, fmt.Sprintf("Level: %s", strings.ToUpper(m.logLevelFilter)))
	}
	if m.autoScrollLogs {
		filterParts = append(filterParts, "[AUTO-SCROLL ON]")
	} else {
		filterParts = append(filterParts, "[AUTO-SCROLL OFF]")
	}

	if len(filterParts) > 0 {
		filters := lipgloss.NewStyle().
			Foreground(amberYellow).
			Italic(true).
			Render("Active: " + strings.Join(filterParts, " | "))
		b.WriteString(filters)
		b.WriteString("\n\n")
	}

	instructions := lipgloss.NewStyle().
		Foreground(lipgloss.Color("#9CA3AF")).
		Italic(true).
		Render("L: Filter Level  |  A: Toggle Auto-Scroll  |  G/g: Jump  |  C: Clear  |  Esc: Back")

	b.WriteString(instructions)
	b.WriteString("\n\n")

	entries := m.getFilteredLogs()

	if len(entries) == 0 {
		noLogs := lipgloss.NewStyle().
			Foreground(lipgloss.Color("#9CA3AF")).
			Italic(true).
			Render("No log entries found")
		b.WriteString(noLogs)
		return b.String()
	}

	totalLogs := len(entries)
	infoCount := 0
	warnCount := 0
	errorCount := 0
	debugCount := 0

	for _, entry := range entries {
		switch strings.ToUpper(entry.level) {
		case "INFO":
			infoCount++
		case "WARN", "WARNING":
			warnCount++
		case "ERROR":
			errorCount++
		case "DEBUG":
			debugCount++
		}
	}

	summary := lipgloss.NewStyle().
		Foreground(tealInfo).
		Bold(true).
		Render(fmt.Sprintf("üìä %d Total | ‚Ñπ %d Info | ‚ö† %d Warn | ‚úó %d Error | üêõ %d Debug",
			totalLogs, infoCount, warnCount, errorCount, debugCount))

	b.WriteString(summary)
	b.WriteString("\n")
	b.WriteString(strings.Repeat("‚îÄ", m.getResponsiveWidth()-4))
	b.WriteString("\n\n")

	maxVisible := 20
	start := 0
	if len(entries) > maxVisible {
		start = len(entries) - maxVisible
		if m.logCursor < start {
			start = m.logCursor
		}
		if m.logCursor >= start+maxVisible {
			start = m.logCursor - maxVisible + 1
		}
	}

	end := start + maxVisible
	if end > len(entries) {
		end = len(entries)
	}

	for i := start; i < end; i++ {
		entry := entries[i]

		cursor := "  "
		if i == m.logCursor {
			cursor = "‚ùØ "
		}

		var levelIcon string
		var levelColor lipgloss.Color
		switch strings.ToUpper(entry.level) {
		case "INFO":
			levelIcon = "‚Ñπ"
			levelColor = tealInfo
		case "WARN", "WARNING":
			levelIcon = "‚ö†"
			levelColor = amberYellow
		case "ERROR":
			levelIcon = "‚úó"
			levelColor = warmRed
		case "DEBUG":
			levelIcon = "üêõ"
			levelColor = mutedGray
		default:
			levelIcon = "¬∑"
			levelColor = offWhite
		}

		levelStr := strings.ToUpper(entry.level)
		if len(levelStr) > 3 {
			levelStr = levelStr[:3]
		}
		level := lipgloss.NewStyle().
			Foreground(levelColor).
			Bold(true).
			Width(5).
			Render(levelIcon + " " + levelStr)

		timestamp := entry.timestamp.Format("15:04:05")
		timeStyle := lipgloss.NewStyle().
			Foreground(lipgloss.Color("#9CA3AF")).
			Width(10)
		timeStr := timeStyle.Render(timestamp)

		vmPart := ""
		if entry.vmName != "" {
			vmStyle := lipgloss.NewStyle().
				Foreground(deepOrange).
				Bold(true)
			vmPart = vmStyle.Render("[" + entry.vmName + "] ")
		}

		message := entry.message
		maxMsgLen := m.getResponsiveWidth() - 60
		if maxMsgLen > 3 && len(message) > maxMsgLen {
			message = message[:maxMsgLen-3] + "..."
		}

		msgStyle := lipgloss.NewStyle()
		if i == m.logCursor {
			msgStyle = msgStyle.Foreground(offWhite).Bold(true)
		}
		msgStr := msgStyle.Render(message)

		line := fmt.Sprintf("%s%s %s %s%s", cursor, level, timeStr, vmPart, msgStr)
		b.WriteString(line)
		b.WriteString("\n")
	}

	if start > 0 {
		b.WriteString("\n")
		b.WriteString(lipgloss.NewStyle().
			Foreground(mutedGray).
			Italic(true).
			Render(fmt.Sprintf("... %d more above (g: top) ...", start)))
	}
	if end < len(entries) {
		b.WriteString("\n")
		b.WriteString(lipgloss.NewStyle().
			Foreground(mutedGray).
			Italic(true).
			Render(fmt.Sprintf("... %d more below (G: bottom) ...", len(entries)-end)))
	}

	return b.String()
}

// buildFolderTree builds a hierarchical folder tree from VM paths
func (m *tuiModel) buildFolderTree() {
	root := &folderNode{
		name:     "VMs",
		path:     "/",
		children: []*folderNode{},
		vms:      []tuiVMItem{},
		expanded: true,
		level:    0,
	}

	for _, vmItem := range m.vms {
		pathParts := strings.Split(strings.Trim(vmItem.vm.Path, "/"), "/")
		current := root

		// Build folder hierarchy
		for i, part := range pathParts[:len(pathParts)-1] {
			found := false
			for _, child := range current.children {
				if child.name == part {
					current = child
					found = true
					break
				}
			}
			if !found {
				newNode := &folderNode{
					name:     part,
					path:     strings.Join(pathParts[:i+1], "/"),
					parent:   current,
					children: []*folderNode{},
					vms:      []tuiVMItem{},
					expanded: false,
					level:    i + 1,
				}
				current.children = append(current.children, newNode)
				current = newNode
			}
		}
		current.vms = append(current.vms, vmItem)
	}

	m.folderTree = root
	m.flattenTree()
}

// flattenTree converts the tree structure into a flat list for rendering
func (m *tuiModel) flattenTree() {
	m.treeItems = []interface{}{}
	var flatten func(*folderNode)
	flatten = func(node *folderNode) {
		if node != m.folderTree {
			m.treeItems = append(m.treeItems, node)
		}
		if node.expanded {
			for _, child := range node.children {
				flatten(child)
			}
			for _, vm := range node.vms {
				m.treeItems = append(m.treeItems, vm)
			}
		}
	}
	flatten(m.folderTree)
}

// toggleFolderAtCursor toggles expand/collapse of folder at cursor
func (m *tuiModel) toggleFolderAtCursor() {
	if m.treeCursor >= len(m.treeItems) {
		return
	}
	if folder, ok := m.treeItems[m.treeCursor].(*folderNode); ok {
		folder.expanded = !folder.expanded
		m.flattenTree()
	}
}

// renderTree renders the folder tree view
func (m tuiModel) renderTree() string {
	var b strings.Builder

	header := lipgloss.NewStyle().
		Foreground(tealInfo).
		Bold(true).
		Render("üìÅ FOLDER TREE VIEW  (T: List View | Enter: Expand/Collapse | Space: Select)")
	b.WriteString(header)
	b.WriteString("\n\n")

	if len(m.treeItems) == 0 {
		b.WriteString("No VMs in tree\n")
		return b.String()
	}

	maxVisible := 20
	start := 0
	if m.treeCursor >= maxVisible {
		start = m.treeCursor - maxVisible + 1
	}
	end := start + maxVisible
	if end > len(m.treeItems) {
		end = len(m.treeItems)
	}

	for i := start; i < end; i++ {
		cursor := "  "
		if i == m.treeCursor {
			cursor = "‚ùØ "
		}

		indent := ""
		var line string

		switch item := m.treeItems[i].(type) {
		case *folderNode:
			indent = strings.Repeat("  ", item.level)
			icon := "üìÅ"
			if item.expanded {
				icon = "üìÇ"
			}
			folderStyle := lipgloss.NewStyle().Foreground(amberYellow).Bold(true)
			line = fmt.Sprintf("%s%s%s %s (%d VMs)", cursor, indent, icon, folderStyle.Render(item.name), len(item.vms))

		case tuiVMItem:
			level := 2
			if folder, ok := m.treeItems[i-1].(*folderNode); ok {
				level = folder.level + 1
			}
			indent = strings.Repeat("  ", level)
			checkbox := "[ ]"
			if item.selected {
				checkbox = "[‚úì]"
			}
			vmStyle := lipgloss.NewStyle()
			if i == m.treeCursor {
				vmStyle = vmStyle.Foreground(tealInfo).Bold(true)
			}
			line = fmt.Sprintf("%s%s%s %s", cursor, indent, checkbox, vmStyle.Render(item.vm.Name))
		}

		b.WriteString(line)
		b.WriteString("\n")
	}

	statusLine := lipgloss.NewStyle().
		Foreground(mutedGray).
		Render(fmt.Sprintf("\n%d items | Selected: %d", len(m.treeItems), m.countSelected()))
	b.WriteString(statusLine)

	return b.String()
}

// renderPreview renders the export preview screen
func (m tuiModel) renderPreview() string {
	var b strings.Builder

	header := lipgloss.NewStyle().
		Foreground(deepOrange).
		Bold(true).
		Render("üìä EXPORT PREVIEW  (Esc/P: Back | Enter: Continue | ‚Üë‚Üì: Navigate)")
	b.WriteString(header)
	b.WriteString("\n\n")

	if len(m.exportPreviews) == 0 {
		b.WriteString(errorStyleTUI.Render("No VMs selected for export"))
		b.WriteString("\n")
		return b.String()
	}

	// Summary section
	summaryTitle := lipgloss.NewStyle().
		Foreground(tealInfo).
		Bold(true).
		Render("Export Summary")
	b.WriteString(summaryTitle)
	b.WriteString("\n")

	totalSize := int64(0)
	totalDuration := time.Duration(0)
	totalDisks := 0
	totalFiles := 0
	for _, preview := range m.exportPreviews {
		totalSize += preview.totalSize
		totalDuration += preview.estimatedDuration
		totalDisks += preview.diskCount
		totalFiles += len(preview.files)
	}

	summaryBox := panelStyleTUI.Render(
		fmt.Sprintf(
			"  VMs: %s\n"+
				"  Total Size: %s\n"+
				"  Total Disks: %s\n"+
				"  Total Files: %s\n"+
				"  Estimated Duration: %s",
			statsStyleTUI.Render(fmt.Sprintf("%d", len(m.exportPreviews))),
			statsStyleTUI.Render(formatBytes(totalSize)),
			statsStyleTUI.Render(fmt.Sprintf("%d", totalDisks)),
			statsStyleTUI.Render(fmt.Sprintf("%d", totalFiles)),
			statsStyleTUI.Render(totalDuration.Round(time.Second).String()),
		),
	)
	b.WriteString(summaryBox)
	b.WriteString("\n\n")

	// Individual VM previews
	previewTitle := lipgloss.NewStyle().
		Foreground(tealInfo).
		Bold(true).
		Render("VM Details")
	b.WriteString(previewTitle)
	b.WriteString("\n\n")

	for i, preview := range m.exportPreviews {
		cursor := "  "
		vmStyle := lipgloss.NewStyle()
		if i == m.previewCursor {
			cursor = "‚ùØ "
			vmStyle = vmStyle.Foreground(deepOrange).Bold(true)
		}

		vmName := vmStyle.Render(preview.vmName)
		b.WriteString(fmt.Sprintf("%s%s\n", cursor, vmName))

		// VM details
		detailStyle := lipgloss.NewStyle().Foreground(mutedGray)
		b.WriteString(detailStyle.Render(fmt.Sprintf("    Size: %s | Disks: %d | Duration: ~%s\n",
			formatBytes(preview.totalSize),
			preview.diskCount,
			preview.estimatedDuration.Round(time.Second),
		)))

		// Disk space check
		if preview.diskSpaceAvail > 0 {
			spaceStatus := "‚úì"
			spaceStyle := successStyleTUI
			spaceMsg := "Sufficient space"

			if preview.diskSpaceNeeded > preview.diskSpaceAvail {
				spaceStatus = "‚úó"
				spaceStyle = errorStyleTUI
				spaceMsg = "INSUFFICIENT SPACE"
			} else if preview.diskSpaceAvail-preview.diskSpaceNeeded < preview.diskSpaceAvail/5 {
				spaceStatus = "‚ö†"
				spaceStyle = lipgloss.NewStyle().Foreground(warningColor).Bold(true)
				spaceMsg = "Low space warning"
			}

			b.WriteString(fmt.Sprintf("    %s Disk Space: %s (Available: %s, Needed: %s)\n",
				spaceStatus,
				spaceStyle.Render(spaceMsg),
				formatBytes(preview.diskSpaceAvail),
				formatBytes(preview.diskSpaceNeeded),
			))
		}

		// File breakdown (only for selected VM)
		if i == m.previewCursor {
			b.WriteString(detailStyle.Render("    Files:\n"))
			for _, file := range preview.files {
				fileTypeIcon := "üìÑ"
				switch file.fileType {
				case "vmdk":
					fileTypeIcon = "üíæ"
				case "ovf":
					fileTypeIcon = "üìã"
				case "mf":
					fileTypeIcon = "üìù"
				}
				b.WriteString(detailStyle.Render(fmt.Sprintf("      %s %s (%s)\n",
					fileTypeIcon,
					file.name,
					formatBytes(file.size),
				)))
			}
		}

		b.WriteString("\n")
	}

	// Help footer
	helpText := helpStyleTUI.Render("Press Enter to continue with export, Esc/P to go back")
	b.WriteString("\n")
	b.WriteString(helpText)
	b.WriteString("\n")

	return b.String()
}

// renderActions renders the quick actions menu
func (m tuiModel) renderActions() string {
	var b strings.Builder

	header := lipgloss.NewStyle().
		Foreground(deepOrange).
		Bold(true).
		Render("‚ö° QUICK ACTIONS  (Esc/X: Back | Enter: Execute | ‚Üë‚Üì: Navigate)")
	b.WriteString(header)
	b.WriteString("\n\n")

	if m.actionsForVM == nil {
		b.WriteString(errorStyleTUI.Render("No VM selected"))
		return b.String()
	}

	// VM info header
	vmHeader := lipgloss.NewStyle().
		Foreground(tealInfo).
		Bold(true).
		Render(fmt.Sprintf("VM: %s", m.actionsForVM.Name))
	b.WriteString(vmHeader)
	b.WriteString("\n")

	vmDetails := lipgloss.NewStyle().
		Foreground(mutedGray).
		Render(fmt.Sprintf("    Power: %s | CPU: %d | Memory: %d MB | Storage: %s",
			m.actionsForVM.PowerState,
			m.actionsForVM.NumCPU,
			m.actionsForVM.MemoryMB,
			formatBytes(m.actionsForVM.Storage),
		))
	b.WriteString(vmDetails)
	b.WriteString("\n\n")

	// Get available actions for this VM
	actions := m.getAvailableActions(m.actionsForVM)

	// Group actions by category
	categories := map[string][]quickAction{
		"power":    {},
		"snapshot": {},
		"export":   {},
		"info":     {},
	}

	for _, action := range actions {
		categories[action.category] = append(categories[action.category], action)
	}

	// Render actions by category
	categoryOrder := []string{"power", "snapshot", "export", "info"}
	categoryTitles := map[string]string{
		"power":    "‚ö° Power Management",
		"snapshot": "üì∏ Snapshot Operations",
		"export":   "üì¶ Export Operations",
		"info":     "‚ÑπÔ∏è  Information",
	}

	actionIndex := 0
	for _, catKey := range categoryOrder {
		catActions := categories[catKey]
		if len(catActions) == 0 {
			continue
		}

		categoryTitle := lipgloss.NewStyle().
			Foreground(amberYellow).
			Bold(true).
			Render(categoryTitles[catKey])
		b.WriteString(categoryTitle)
		b.WriteString("\n")

		for _, action := range catActions {
			cursor := "  "
			actionStyle := lipgloss.NewStyle()

			if actionIndex == m.actionsCursor {
				cursor = "‚ùØ "
				actionStyle = actionStyle.
					Foreground(deepOrange).
					Bold(true).
					Background(lightBg)
			} else {
				actionStyle = actionStyle.Foreground(offWhite)
			}

			enabled := action.enabled(m.actionsForVM)
			disabledIndicator := ""
			if !enabled {
				actionStyle = actionStyle.Foreground(mutedGray)
				disabledIndicator = " (disabled)"
			}

			line := fmt.Sprintf("%s%s %s%s", cursor, action.icon, action.name, disabledIndicator)
			b.WriteString(actionStyle.Render(line))
			b.WriteString("\n")

			if actionIndex == m.actionsCursor {
				desc := lipgloss.NewStyle().
					Foreground(mutedGray).
					Italic(true).
					Render(fmt.Sprintf("    %s", action.description))
				b.WriteString(desc)
				b.WriteString("\n")
			}

			actionIndex++
		}
		b.WriteString("\n")
	}

	// Help footer
	helpText := helpStyleTUI.Render("Press Enter to execute action, Esc/X to go back")
	b.WriteString("\n")
	b.WriteString(helpText)
	b.WriteString("\n")

	return b.String()
}

// handleActionsKeys handles keyboard input in actions menu
func (m tuiModel) handleActionsKeys(msg tea.KeyMsg) (tea.Model, tea.Cmd) {
	actions := m.getAvailableActions(m.actionsForVM)
	totalActions := len(actions)

	switch msg.String() {
	case "ctrl+c", "q":
		return m, tea.Quit

	case "escape", "x", "X":
		// Return to select phase
		m.phase = "select"
		m.showActionsMenu = false
		m.actionsForVM = nil
		return m, nil

	case "up", "k":
		if m.actionsCursor > 0 {
			m.actionsCursor--
		}

	case "down", "j":
		if m.actionsCursor < totalActions-1 {
			m.actionsCursor++
		}

	case "enter":
		// Execute the selected action
		if m.actionsCursor < len(actions) {
			action := actions[m.actionsCursor]
			if action.enabled(m.actionsForVM) {
				m.phase = "select"
				m.showActionsMenu = false
				return action.handler(&m, m.actionsForVM)
			} else {
				m.message = "This action is not available for the current VM state"
			}
		}
	}

	return m, nil
}

// getAvailableActions returns list of available actions for a VM
func (m tuiModel) getAvailableActions(vm *vsphere.VMInfo) []quickAction {
	if vm == nil {
		return []quickAction{}
	}

	actions := []quickAction{
		// Power actions
		{
			name:        "Power On",
			description: "Power on the virtual machine",
			icon:        "‚ñ∂Ô∏è",
			category:    "power",
			enabled: func(v *vsphere.VMInfo) bool {
				return v.PowerState == "poweredOff"
			},
			handler: func(m *tuiModel, v *vsphere.VMInfo) (tea.Model, tea.Cmd) {
				m.message = fmt.Sprintf("Power on operation not yet implemented for %s", v.Name)
				return *m, nil
			},
		},
		{
			name:        "Power Off",
			description: "Power off the virtual machine (graceful shutdown)",
			icon:        "‚èπÔ∏è",
			category:    "power",
			enabled: func(v *vsphere.VMInfo) bool {
				return v.PowerState == "poweredOn"
			},
			handler: func(m *tuiModel, v *vsphere.VMInfo) (tea.Model, tea.Cmd) {
				m.message = fmt.Sprintf("Power off operation not yet implemented for %s", v.Name)
				return *m, nil
			},
		},
		{
			name:        "Reset (Hard Reboot)",
			description: "Force reset the virtual machine (equivalent to power cycle)",
			icon:        "üîÑ",
			category:    "power",
			enabled: func(v *vsphere.VMInfo) bool {
				return v.PowerState == "poweredOn"
			},
			handler: func(m *tuiModel, v *vsphere.VMInfo) (tea.Model, tea.Cmd) {
				m.message = fmt.Sprintf("Reset operation not yet implemented for %s", v.Name)
				return *m, nil
			},
		},
		{
			name:        "Suspend",
			description: "Suspend the virtual machine to save its current state",
			icon:        "‚è∏Ô∏è",
			category:    "power",
			enabled: func(v *vsphere.VMInfo) bool {
				return v.PowerState == "poweredOn"
			},
			handler: func(m *tuiModel, v *vsphere.VMInfo) (tea.Model, tea.Cmd) {
				m.message = fmt.Sprintf("Suspend operation not yet implemented for %s", v.Name)
				return *m, nil
			},
		},

		// Snapshot actions
		{
			name:        "Create Snapshot",
			description: "Create a point-in-time snapshot of the VM",
			icon:        "üì∏",
			category:    "snapshot",
			enabled: func(v *vsphere.VMInfo) bool {
				return true // Always available
			},
			handler: func(m *tuiModel, v *vsphere.VMInfo) (tea.Model, tea.Cmd) {
				m.message = fmt.Sprintf("Snapshot creation not yet implemented for %s", v.Name)
				return *m, nil
			},
		},
		{
			name:        "Delete All Snapshots",
			description: "Remove all snapshots and reclaim disk space",
			icon:        "üóëÔ∏è",
			category:    "snapshot",
			enabled: func(v *vsphere.VMInfo) bool {
				return true // Would need to check if snapshots exist
			},
			handler: func(m *tuiModel, v *vsphere.VMInfo) (tea.Model, tea.Cmd) {
				m.message = fmt.Sprintf("Snapshot deletion not yet implemented for %s", v.Name)
				return *m, nil
			},
		},
		{
			name:        "Consolidate Snapshots",
			description: "Consolidate snapshot disks and commit changes",
			icon:        "üìä",
			category:    "snapshot",
			enabled: func(v *vsphere.VMInfo) bool {
				return true
			},
			handler: func(m *tuiModel, v *vsphere.VMInfo) (tea.Model, tea.Cmd) {
				m.message = fmt.Sprintf("Snapshot consolidation not yet implemented for %s", v.Name)
				return *m, nil
			},
		},

		// Export actions
		{
			name:        "Quick Export (OVF)",
			description: "Fast export without compression",
			icon:        "üì§",
			category:    "export",
			enabled: func(v *vsphere.VMInfo) bool {
				return true
			},
			handler: func(m *tuiModel, v *vsphere.VMInfo) (tea.Model, tea.Cmd) {
				// Select this VM and proceed to export
				for i := range m.vms {
					m.vms[i].selected = (m.vms[i].vm.Path == v.Path)
				}
				m.phase = "confirm"
				return *m, nil
			},
		},
		{
			name:        "Production Export (OVA)",
			description: "Compressed OVA with verification",
			icon:        "üì¶",
			category:    "export",
			enabled: func(v *vsphere.VMInfo) bool {
				return true
			},
			handler: func(m *tuiModel, v *vsphere.VMInfo) (tea.Model, tea.Cmd) {
				// Select this VM and proceed to export with template
				for i := range m.vms {
					m.vms[i].selected = (m.vms[i].vm.Path == v.Path)
				}
				m.selectedTemplate = &exportTemplates[1] // Production template
				m.phase = "confirm"
				return *m, nil
			},
		},

		// Info actions
		{
			name:        "Show Detailed Info",
			description: "Display comprehensive VM information",
			icon:        "‚ÑπÔ∏è",
			category:    "info",
			enabled: func(v *vsphere.VMInfo) bool {
				return true
			},
			handler: func(m *tuiModel, v *vsphere.VMInfo) (tea.Model, tea.Cmd) {
				m.detailsVM = v
				m.phase = "details"
				return *m, nil
			},
		},
		{
			name:        "Run Pre-Export Validation",
			description: "Check if VM is ready for export",
			icon:        "‚úÖ",
			category:    "info",
			enabled: func(v *vsphere.VMInfo) bool {
				return true
			},
			handler: func(m *tuiModel, v *vsphere.VMInfo) (tea.Model, tea.Cmd) {
				// Select this VM and show validation
				for i := range m.vms {
					m.vms[i].selected = (m.vms[i].vm.Path == v.Path)
				}
				m.phase = "validation"
				return *m, m.runValidation()
			},
		},
	}

	return actions
}

// renderBulkOps renders the bulk operations menu
func (m tuiModel) renderBulkOps() string {
	var b strings.Builder

	header := lipgloss.NewStyle().
		Foreground(deepOrange).
		Bold(true).
		Render("‚öôÔ∏è  BULK OPERATIONS  (Esc/B: Back | Enter: Execute | ‚Üë‚Üì: Navigate)")
	b.WriteString(header)
	b.WriteString("\n\n")

	selectedVMs := m.getSelectedVMs()
	if len(selectedVMs) == 0 {
		b.WriteString(errorStyleTUI.Render("No VMs selected"))
		return b.String()
	}

	// Summary of selected VMs
	summaryHeader := lipgloss.NewStyle().
		Foreground(tealInfo).
		Bold(true).
		Render(fmt.Sprintf("Selected VMs: %d", len(selectedVMs)))
	b.WriteString(summaryHeader)
	b.WriteString("\n")

	// Show first few VM names
	maxShow := 5
	for i, vmItem := range selectedVMs {
		if i >= maxShow {
			b.WriteString(lipgloss.NewStyle().
				Foreground(mutedGray).
				Render(fmt.Sprintf("    ... and %d more\n", len(selectedVMs)-maxShow)))
			break
		}
		vmLine := lipgloss.NewStyle().
			Foreground(mutedGray).
			Render(fmt.Sprintf("    ‚Ä¢ %s (%s)\n", vmItem.vm.Name, vmItem.vm.PowerState))
		b.WriteString(vmLine)
	}
	b.WriteString("\n")

	// Get available bulk operations
	operations := m.getBulkOperations(selectedVMs)

	// Group operations by category
	categories := map[string][]bulkOperation{
		"power":       {},
		"snapshot":    {},
		"maintenance": {},
	}

	for _, op := range operations {
		categories[op.category] = append(categories[op.category], op)
	}

	// Render operations by category
	categoryOrder := []string{"power", "snapshot", "maintenance"}
	categoryTitles := map[string]string{
		"power":       "‚ö° Power Management",
		"snapshot":    "üì∏ Snapshot Operations",
		"maintenance": "üîß Maintenance",
	}

	opIndex := 0
	for _, catKey := range categoryOrder {
		catOps := categories[catKey]
		if len(catOps) == 0 {
			continue
		}

		categoryTitle := lipgloss.NewStyle().
			Foreground(amberYellow).
			Bold(true).
			Render(categoryTitles[catKey])
		b.WriteString(categoryTitle)
		b.WriteString("\n")

		for _, op := range catOps {
			cursor := "  "
			opStyle := lipgloss.NewStyle()

			if opIndex == m.bulkOpsCursor {
				cursor = "‚ùØ "
				opStyle = opStyle.
					Foreground(deepOrange).
					Bold(true).
					Background(lightBg)
			} else {
				opStyle = opStyle.Foreground(offWhite)
			}

			vmInfos := make([]vsphere.VMInfo, len(selectedVMs))
			for i, vm := range selectedVMs {
				vmInfos[i] = vm.vm
			}

			enabled := op.enabled(vmInfos)
			disabledIndicator := ""
			if !enabled {
				opStyle = opStyle.Foreground(mutedGray)
				disabledIndicator = " (not available)"
			}

			line := fmt.Sprintf("%s%s %s%s", cursor, op.icon, op.name, disabledIndicator)
			b.WriteString(opStyle.Render(line))
			b.WriteString("\n")

			if opIndex == m.bulkOpsCursor {
				desc := lipgloss.NewStyle().
					Foreground(mutedGray).
					Italic(true).
					Render(fmt.Sprintf("    %s", op.description))
				b.WriteString(desc)
				b.WriteString("\n")

				// Show warning for destructive operations
				if strings.Contains(op.name, "Power Off") || strings.Contains(op.name, "Delete") || strings.Contains(op.name, "Reset") {
					warning := lipgloss.NewStyle().
						Foreground(warningColor).
						Bold(true).
						Render(fmt.Sprintf("    ‚ö†Ô∏è  Warning: This will affect %d VMs!", len(selectedVMs)))
					b.WriteString(warning)
					b.WriteString("\n")
				}
			}

			opIndex++
		}
		b.WriteString("\n")
	}

	// Help footer
	helpText := helpStyleTUI.Render("Press Enter to execute operation on all selected VMs, Esc/B to go back")
	b.WriteString("\n")
	b.WriteString(helpText)
	b.WriteString("\n")

	return b.String()
}

// handleBulkOpsKeys handles keyboard input in bulk operations menu
func (m tuiModel) handleBulkOpsKeys(msg tea.KeyMsg) (tea.Model, tea.Cmd) {
	selectedVMs := m.getSelectedVMs()
	vmInfos := make([]vsphere.VMInfo, len(selectedVMs))
	for i, vm := range selectedVMs {
		vmInfos[i] = vm.vm
	}

	operations := m.getBulkOperations(selectedVMs)
	totalOps := len(operations)

	switch msg.String() {
	case "ctrl+c", "q":
		return m, tea.Quit

	case "escape", "b", "B":
		// Return to select phase
		m.phase = "select"
		m.showBulkOps = false
		return m, nil

	case "up", "k":
		if m.bulkOpsCursor > 0 {
			m.bulkOpsCursor--
		}

	case "down", "j":
		if m.bulkOpsCursor < totalOps-1 {
			m.bulkOpsCursor++
		}

	case "enter":
		// Execute the selected bulk operation
		if m.bulkOpsCursor < len(operations) {
			op := operations[m.bulkOpsCursor]
			if op.enabled(vmInfos) {
				// Show confirmation message
				m.message = fmt.Sprintf("Executing '%s' on %d VMs... (not yet implemented)", op.name, len(selectedVMs))
				m.phase = "select"
				m.showBulkOps = false
				// In a real implementation, would execute: return op.handler(&m, vmInfos)
				return m, nil
			} else {
				m.message = "This operation is not available for the current VM selection"
			}
		}
	}

	return m, nil
}

// getBulkOperations returns list of available bulk operations
func (m tuiModel) getBulkOperations(selectedVMs []tuiVMItem) []bulkOperation {
	if len(selectedVMs) == 0 {
		return []bulkOperation{}
	}

	operations := []bulkOperation{
		// Power operations
		{
			name:        "Power On All",
			description: "Power on all selected virtual machines",
			icon:        "‚ñ∂Ô∏è",
			category:    "power",
			confirmText: "Are you sure you want to power on all selected VMs?",
			enabled: func(vms []vsphere.VMInfo) bool {
				// Check if at least one VM is powered off
				for _, vm := range vms {
					if vm.PowerState == "poweredOff" {
						return true
					}
				}
				return false
			},
			handler: func(m *tuiModel, vms []vsphere.VMInfo) tea.Cmd {
				// Placeholder for bulk power on
				return nil
			},
		},
		{
			name:        "Power Off All",
			description: "Gracefully shutdown all selected virtual machines",
			icon:        "‚èπÔ∏è",
			category:    "power",
			confirmText: "Are you sure you want to power off all selected VMs?",
			enabled: func(vms []vsphere.VMInfo) bool {
				// Check if at least one VM is powered on
				for _, vm := range vms {
					if vm.PowerState == "poweredOn" {
						return true
					}
				}
				return false
			},
			handler: func(m *tuiModel, vms []vsphere.VMInfo) tea.Cmd {
				// Placeholder for bulk power off
				return nil
			},
		},
		{
			name:        "Reset All",
			description: "Force reset all selected virtual machines (hard reboot)",
			icon:        "üîÑ",
			category:    "power",
			confirmText: "Are you sure you want to reset all selected VMs? This is a hard reboot!",
			enabled: func(vms []vsphere.VMInfo) bool {
				// Check if at least one VM is powered on
				for _, vm := range vms {
					if vm.PowerState == "poweredOn" {
						return true
					}
				}
				return false
			},
			handler: func(m *tuiModel, vms []vsphere.VMInfo) tea.Cmd {
				// Placeholder for bulk reset
				return nil
			},
		},

		// Snapshot operations
		{
			name:        "Create Snapshots",
			description: "Create a point-in-time snapshot for all selected VMs",
			icon:        "üì∏",
			category:    "snapshot",
			confirmText: "Create snapshots for all selected VMs?",
			enabled: func(vms []vsphere.VMInfo) bool {
				return true // Always available
			},
			handler: func(m *tuiModel, vms []vsphere.VMInfo) tea.Cmd {
				// Placeholder for bulk snapshot creation
				return nil
			},
		},
		{
			name:        "Delete All Snapshots",
			description: "Remove all snapshots from selected VMs and reclaim disk space",
			icon:        "üóëÔ∏è",
			category:    "snapshot",
			confirmText: "Delete all snapshots from selected VMs? This cannot be undone!",
			enabled: func(vms []vsphere.VMInfo) bool {
				return true // Would need to check if snapshots exist
			},
			handler: func(m *tuiModel, vms []vsphere.VMInfo) tea.Cmd {
				// Placeholder for bulk snapshot deletion
				return nil
			},
		},
		{
			name:        "Consolidate Snapshots",
			description: "Consolidate snapshot disks for all selected VMs",
			icon:        "üìä",
			category:    "snapshot",
			confirmText: "Consolidate snapshots for all selected VMs?",
			enabled: func(vms []vsphere.VMInfo) bool {
				return true
			},
			handler: func(m *tuiModel, vms []vsphere.VMInfo) tea.Cmd {
				// Placeholder for bulk snapshot consolidation
				return nil
			},
		},

		// Maintenance operations
		{
			name:        "Tag All VMs",
			description: "Apply tags to all selected VMs",
			icon:        "üè∑Ô∏è",
			category:    "maintenance",
			confirmText: "Tag all selected VMs?",
			enabled: func(vms []vsphere.VMInfo) bool {
				return true
			},
			handler: func(m *tuiModel, vms []vsphere.VMInfo) tea.Cmd {
				// Placeholder for bulk tagging
				return nil
			},
		},
		{
			name:        "Update VMware Tools",
			description: "Update VMware Tools on all selected VMs",
			icon:        "üîß",
			category:    "maintenance",
			confirmText: "Update VMware Tools on all selected VMs?",
			enabled: func(vms []vsphere.VMInfo) bool {
				// Check if at least one VM is powered on
				for _, vm := range vms {
					if vm.PowerState == "poweredOn" {
						return true
					}
				}
				return false
			},
			handler: func(m *tuiModel, vms []vsphere.VMInfo) tea.Cmd {
				// Placeholder for VMware Tools update
				return nil
			},
		},
		{
			name:        "Change Resource Allocation",
			description: "Modify CPU/memory allocation for all selected VMs",
			icon:        "‚öôÔ∏è",
			category:    "maintenance",
			confirmText: "Change resource allocation for all selected VMs?",
			enabled: func(vms []vsphere.VMInfo) bool {
				return true
			},
			handler: func(m *tuiModel, vms []vsphere.VMInfo) tea.Cmd {
				// Placeholder for resource allocation change
				return nil
			},
		},
	}

	return operations
}

// renderCompare renders the VM comparison view
func (m tuiModel) renderCompare() string {
	var b strings.Builder

	// Header
	modeText := map[string]string{
		"overview":  "OVERVIEW",
		"resources": "RESOURCES",
		"storage":   "STORAGE",
		"network":   "NETWORK",
	}
	header := lipgloss.NewStyle().
		Foreground(deepOrange).
		Bold(true).
		Render(fmt.Sprintf("üîç VM COMPARISON - %s  (Esc/C: Back | 1-4: Switch Mode | ‚Üë‚Üì: Scroll)", modeText[m.comparisonMode]))
	b.WriteString(header)
	b.WriteString("\n\n")

	if len(m.comparisonVMs) < 2 {
		b.WriteString(errorStyleTUI.Render("Need at least 2 VMs to compare"))
		return b.String()
	}

	// Mode selector
	modeBar := lipgloss.NewStyle().
		Foreground(mutedGray).
		Render("Modes: ")

	modes := []string{"1:Overview", "2:Resources", "3:Storage", "4:Network"}
	modeMapping := []string{"overview", "resources", "storage", "network"}

	for i, modeLabel := range modes {
		if modeMapping[i] == m.comparisonMode {
			modeBar += lipgloss.NewStyle().
				Foreground(deepOrange).
				Bold(true).
				Background(lightBg).
				Render(fmt.Sprintf(" [%s] ", modeLabel))
		} else {
			modeBar += lipgloss.NewStyle().
				Foreground(mutedGray).
				Render(fmt.Sprintf("  %s  ", modeLabel))
		}
	}
	b.WriteString(modeBar)
	b.WriteString("\n\n")

	// Build comparison table based on mode
	switch m.comparisonMode {
	case "overview":
		b.WriteString(m.renderComparisonOverview())
	case "resources":
		b.WriteString(m.renderComparisonResources())
	case "storage":
		b.WriteString(m.renderComparisonStorage())
	case "network":
		b.WriteString(m.renderComparisonNetwork())
	}

	// Help footer
	helpText := helpStyleTUI.Render("1-4: Switch comparison mode | Esc/C: Back to selection")
	b.WriteString("\n")
	b.WriteString(helpText)
	b.WriteString("\n")

	return b.String()
}

// renderComparisonOverview renders the overview comparison table
func (m tuiModel) renderComparisonOverview() string {
	var b strings.Builder

	// Column widths
	labelWidth := 20
	colWidth := 25

	// Header row
	headerStyle := lipgloss.NewStyle().Foreground(tealInfo).Bold(true)
	b.WriteString(lipgloss.NewStyle().Width(labelWidth).Render("Property"))
	for _, vm := range m.comparisonVMs {
		vmName := vm.Name
		if len(vmName) > colWidth-2 {
			vmName = vmName[:colWidth-5] + "..."
		}
		b.WriteString(headerStyle.Render(lipgloss.NewStyle().Width(colWidth).Render(vmName)))
	}
	b.WriteString("\n")
	b.WriteString(strings.Repeat("‚îÄ", labelWidth+colWidth*len(m.comparisonVMs)))
	b.WriteString("\n")

	// Data rows
	rows := []struct {
		label  string
		getter func(vsphere.VMInfo) string
		diff   bool // highlight differences
	}{
		{"Name", func(vm vsphere.VMInfo) string { return vm.Name }, false},
		{"Power State", func(vm vsphere.VMInfo) string { return vm.PowerState }, true},
		{"Guest OS", func(vm vsphere.VMInfo) string { return vm.GuestOS }, true},
		{"vCPUs", func(vm vsphere.VMInfo) string { return fmt.Sprintf("%d", vm.NumCPU) }, true},
		{"Memory (GB)", func(vm vsphere.VMInfo) string { return fmt.Sprintf("%.1f", float64(vm.MemoryMB)/1024) }, true},
		{"Storage", func(vm vsphere.VMInfo) string { return formatBytes(vm.Storage) }, true},
		{"Path", func(vm vsphere.VMInfo) string { return vm.Path }, false},
	}

	for _, row := range rows {
		labelStyle := lipgloss.NewStyle().Foreground(amberYellow)
		b.WriteString(labelStyle.Render(lipgloss.NewStyle().Width(labelWidth).Render(row.label)))

		values := make([]string, len(m.comparisonVMs))
		for i, vm := range m.comparisonVMs {
			values[i] = row.getter(vm)
		}

		// Check if values differ
		allSame := true
		if row.diff && len(values) > 1 {
			for i := 1; i < len(values); i++ {
				if values[i] != values[0] {
					allSame = false
					break
				}
			}
		}

		// Render values
		for _, val := range values {
			cellStyle := lipgloss.NewStyle()
			if row.diff && !allSame {
				cellStyle = cellStyle.Foreground(warningColor).Bold(true)
			} else {
				cellStyle = cellStyle.Foreground(offWhite)
			}
			b.WriteString(cellStyle.Render(lipgloss.NewStyle().Width(colWidth).Render(val)))
		}
		b.WriteString("\n")
	}

	return b.String()
}

// renderComparisonResources renders resource comparison
func (m tuiModel) renderComparisonResources() string {
	var b strings.Builder

	labelWidth := 20
	colWidth := 25

	// Header
	headerStyle := lipgloss.NewStyle().Foreground(tealInfo).Bold(true)
	b.WriteString(lipgloss.NewStyle().Width(labelWidth).Render("Resource"))
	for _, vm := range m.comparisonVMs {
		vmName := vm.Name
		if len(vmName) > colWidth-2 {
			vmName = vmName[:colWidth-5] + "..."
		}
		b.WriteString(headerStyle.Render(lipgloss.NewStyle().Width(colWidth).Render(vmName)))
	}
	b.WriteString("\n")
	b.WriteString(strings.Repeat("‚îÄ", labelWidth+colWidth*len(m.comparisonVMs)))
	b.WriteString("\n")

	// CPU section
	sectionStyle := lipgloss.NewStyle().Foreground(deepOrange).Bold(true)
	b.WriteString(sectionStyle.Render("CPU"))
	b.WriteString("\n")

	rows := []struct {
		label  string
		getter func(vsphere.VMInfo) string
	}{
		{"vCPUs", func(vm vsphere.VMInfo) string { return fmt.Sprintf("%d", vm.NumCPU) }},
		{"CPU Sockets", func(vm vsphere.VMInfo) string { return "N/A" }}, // Would need additional data
		{"Cores per Socket", func(vm vsphere.VMInfo) string { return "N/A" }},
	}

	for _, row := range rows {
		labelStyle := lipgloss.NewStyle().Foreground(mutedGray).Render("  " + row.label)
		b.WriteString(lipgloss.NewStyle().Width(labelWidth).Render(labelStyle))

		for _, vm := range m.comparisonVMs {
			val := row.getter(vm)
			b.WriteString(lipgloss.NewStyle().Width(colWidth).Foreground(offWhite).Render(val))
		}
		b.WriteString("\n")
	}

	b.WriteString("\n")
	b.WriteString(sectionStyle.Render("Memory"))
	b.WriteString("\n")

	memRows := []struct {
		label  string
		getter func(vsphere.VMInfo) string
	}{
		{"Total Memory (MB)", func(vm vsphere.VMInfo) string { return fmt.Sprintf("%d", vm.MemoryMB) }},
		{"Memory (GB)", func(vm vsphere.VMInfo) string { return fmt.Sprintf("%.2f", float64(vm.MemoryMB)/1024) }},
		{"Reservation", func(vm vsphere.VMInfo) string { return "N/A" }},
	}

	for _, row := range memRows {
		labelStyle := lipgloss.NewStyle().Foreground(mutedGray).Render("  " + row.label)
		b.WriteString(lipgloss.NewStyle().Width(labelWidth).Render(labelStyle))

		for _, vm := range m.comparisonVMs {
			val := row.getter(vm)
			b.WriteString(lipgloss.NewStyle().Width(colWidth).Foreground(offWhite).Render(val))
		}
		b.WriteString("\n")
	}

	return b.String()
}

// renderComparisonStorage renders storage comparison
func (m tuiModel) renderComparisonStorage() string {
	var b strings.Builder

	labelWidth := 20
	colWidth := 25

	// Header
	headerStyle := lipgloss.NewStyle().Foreground(tealInfo).Bold(true)
	b.WriteString(lipgloss.NewStyle().Width(labelWidth).Render("Storage"))
	for _, vm := range m.comparisonVMs {
		vmName := vm.Name
		if len(vmName) > colWidth-2 {
			vmName = vmName[:colWidth-5] + "..."
		}
		b.WriteString(headerStyle.Render(lipgloss.NewStyle().Width(colWidth).Render(vmName)))
	}
	b.WriteString("\n")
	b.WriteString(strings.Repeat("‚îÄ", labelWidth+colWidth*len(m.comparisonVMs)))
	b.WriteString("\n")

	rows := []struct {
		label  string
		getter func(vsphere.VMInfo) string
	}{
		{"Total Storage", func(vm vsphere.VMInfo) string { return formatBytes(vm.Storage) }},
		{"Storage (GB)", func(vm vsphere.VMInfo) string { return fmt.Sprintf("%.2f", float64(vm.Storage)/(1024*1024*1024)) }},
		{"Disk Count", func(vm vsphere.VMInfo) string { return "N/A" }}, // Would need additional data
		{"Provisioning", func(vm vsphere.VMInfo) string { return "N/A" }},
		{"Datastore", func(vm vsphere.VMInfo) string { return "N/A" }},
	}

	for _, row := range rows {
		labelStyle := lipgloss.NewStyle().Foreground(amberYellow)
		b.WriteString(labelStyle.Render(lipgloss.NewStyle().Width(labelWidth).Render(row.label)))

		for _, vm := range m.comparisonVMs {
			val := row.getter(vm)
			b.WriteString(lipgloss.NewStyle().Width(colWidth).Foreground(offWhite).Render(val))
		}
		b.WriteString("\n")
	}

	return b.String()
}

// renderComparisonNetwork renders network comparison
func (m tuiModel) renderComparisonNetwork() string {
	var b strings.Builder

	labelWidth := 20
	colWidth := 25

	// Header
	headerStyle := lipgloss.NewStyle().Foreground(tealInfo).Bold(true)
	b.WriteString(lipgloss.NewStyle().Width(labelWidth).Render("Network"))
	for _, vm := range m.comparisonVMs {
		vmName := vm.Name
		if len(vmName) > colWidth-2 {
			vmName = vmName[:colWidth-5] + "..."
		}
		b.WriteString(headerStyle.Render(lipgloss.NewStyle().Width(colWidth).Render(vmName)))
	}
	b.WriteString("\n")
	b.WriteString(strings.Repeat("‚îÄ", labelWidth+colWidth*len(m.comparisonVMs)))
	b.WriteString("\n")

	// Note about limited data
	noteStyle := lipgloss.NewStyle().Foreground(mutedGray).Italic(true)
	b.WriteString(noteStyle.Render("Network information would require additional VM data"))
	b.WriteString("\n\n")

	rows := []struct {
		label  string
		getter func(vsphere.VMInfo) string
	}{
		{"NICs", func(vm vsphere.VMInfo) string { return "N/A" }},
		{"Network 1", func(vm vsphere.VMInfo) string { return "N/A" }},
		{"MAC Address", func(vm vsphere.VMInfo) string { return "N/A" }},
		{"Adapter Type", func(vm vsphere.VMInfo) string { return "N/A" }},
	}

	for _, row := range rows {
		labelStyle := lipgloss.NewStyle().Foreground(amberYellow)
		b.WriteString(labelStyle.Render(lipgloss.NewStyle().Width(labelWidth).Render(row.label)))

		for _, vm := range m.comparisonVMs {
			val := row.getter(vm)
			b.WriteString(lipgloss.NewStyle().Width(colWidth).Foreground(mutedGray).Render(val))
		}
		b.WriteString("\n")
	}

	return b.String()
}

// handleCompareKeys handles keyboard input in comparison view
func (m tuiModel) handleCompareKeys(msg tea.KeyMsg) (tea.Model, tea.Cmd) {
	switch msg.String() {
	case "ctrl+c", "q":
		return m, tea.Quit

	case "escape", "C":
		// Return to select phase
		m.phase = "select"
		m.showComparison = false
		m.comparisonVMs = nil
		return m, nil

	case "1":
		m.comparisonMode = "overview"
	case "2":
		m.comparisonMode = "resources"
	case "3":
		m.comparisonMode = "storage"
	case "4":
		m.comparisonMode = "network"

	case "up", "k":
		if m.comparisonScroll > 0 {
			m.comparisonScroll--
		}

	case "down", "j":
		m.comparisonScroll++
	}

	return m, nil
}

// renderBookmarks renders the bookmarks and saved filters view
func (m tuiModel) renderBookmarks() string {
	var b strings.Builder

	header := lipgloss.NewStyle().
		Foreground(deepOrange).
		Bold(true).
		Render("üìå BOOKMARKS & SAVED FILTERS  (Esc/M: Back | Enter: Apply | S: Save Current | D: Delete)")
	b.WriteString(header)
	b.WriteString("\n\n")

	// Bookmarks section
	bookmarkTitle := lipgloss.NewStyle().
		Foreground(tealInfo).
		Bold(true).
		Render("VM Bookmarks")
	b.WriteString(bookmarkTitle)
	b.WriteString("\n")

	if len(m.bookmarks) == 0 {
		b.WriteString(lipgloss.NewStyle().
			Foreground(mutedGray).
			Render("  No bookmarks saved. Select VMs and press 'S' to save."))
		b.WriteString("\n")
	} else {
		for i, bookmark := range m.bookmarks {
			cursor := "  "
			bookmarkStyle := lipgloss.NewStyle()

			if i == m.bookmarkCursor {
				cursor = "‚ùØ "
				bookmarkStyle = bookmarkStyle.
					Foreground(deepOrange).
					Bold(true).
					Background(lightBg)
			} else {
				bookmarkStyle = bookmarkStyle.Foreground(offWhite)
			}

			line := fmt.Sprintf("%s%s %s (%d VMs)", cursor, bookmark.icon, bookmark.name, len(bookmark.vmPaths))
			b.WriteString(bookmarkStyle.Render(line))
			b.WriteString("\n")

			if i == m.bookmarkCursor {
				desc := lipgloss.NewStyle().
					Foreground(mutedGray).
					Italic(true).
					Render(fmt.Sprintf("    %s", bookmark.description))
				b.WriteString(desc)
				b.WriteString("\n")
			}
		}
	}

	b.WriteString("\n")

	// Saved filters section
	filterTitle := lipgloss.NewStyle().
		Foreground(tealInfo).
		Bold(true).
		Render("Saved Filters")
	b.WriteString(filterTitle)
	b.WriteString("\n")

	if len(m.savedFilters) == 0 {
		b.WriteString(lipgloss.NewStyle().
			Foreground(mutedGray).
			Render("  No filters saved. Press 'S' to save current filter."))
		b.WriteString("\n")
	} else {
		filterStartIdx := len(m.bookmarks)
		for i, filter := range m.savedFilters {
			cursor := "  "
			filterStyle := lipgloss.NewStyle()

			cursorIdx := filterStartIdx + i
			if cursorIdx == m.bookmarkCursor {
				cursor = "‚ùØ "
				filterStyle = filterStyle.
					Foreground(deepOrange).
					Bold(true).
					Background(lightBg)
			} else {
				filterStyle = filterStyle.Foreground(offWhite)
			}

			line := fmt.Sprintf("%süîç %s", cursor, filter.name)
			b.WriteString(filterStyle.Render(line))
			b.WriteString("\n")

			if cursorIdx == m.bookmarkCursor {
				desc := lipgloss.NewStyle().
					Foreground(mutedGray).
					Italic(true).
					Render(fmt.Sprintf("    %s", filter.description))
				b.WriteString(desc)
				b.WriteString("\n")

				// Show filter criteria
				criteria := ""
				if filter.powerState != "" {
					criteria += fmt.Sprintf("Power: %s | ", filter.powerState)
				}
				if filter.osFilter != "" {
					criteria += fmt.Sprintf("OS: %s | ", filter.osFilter)
				}
				if filter.minCPU > 0 {
					criteria += fmt.Sprintf("CPU ‚â• %d | ", filter.minCPU)
				}
				if filter.minMemoryGB > 0 {
					criteria += fmt.Sprintf("Memory ‚â• %.1f GB | ", filter.minMemoryGB)
				}
				if filter.searchQuery != "" {
					criteria += fmt.Sprintf("Search: '%s'", filter.searchQuery)
				}

				if criteria != "" {
					criteriaStyle := lipgloss.NewStyle().
						Foreground(amberYellow).
						Render(fmt.Sprintf("    %s", criteria))
					b.WriteString(criteriaStyle)
					b.WriteString("\n")
				}
			}
		}
	}

	// Help footer
	helpText := helpStyleTUI.Render("Enter: Apply | S: Save current selection/filter | D: Delete | Esc/M: Back")
	b.WriteString("\n")
	b.WriteString(helpText)
	b.WriteString("\n")

	return b.String()
}

// handleBookmarksKeys handles keyboard input in bookmarks view
func (m tuiModel) handleBookmarksKeys(msg tea.KeyMsg) (tea.Model, tea.Cmd) {
	totalItems := len(m.bookmarks) + len(m.savedFilters)

	switch msg.String() {
	case "ctrl+c", "q":
		return m, tea.Quit

	case "escape", "m", "M":
		// Return to select phase
		m.phase = "select"
		m.showBookmarks = false
		return m, nil

	case "up", "k":
		if m.bookmarkCursor > 0 {
			m.bookmarkCursor--
		}

	case "down", "j":
		if m.bookmarkCursor < totalItems-1 {
			m.bookmarkCursor++
		}

	case "enter":
		// Apply the selected bookmark or filter
		if m.bookmarkCursor < len(m.bookmarks) {
			// Apply bookmark
			bookmark := m.bookmarks[m.bookmarkCursor]
			m.applyBookmark(bookmark)
			m.message = fmt.Sprintf("‚úì Applied bookmark: %s (%d VMs selected)", bookmark.name, len(bookmark.vmPaths))
			m.phase = "select"
			m.showBookmarks = false
		} else {
			// Apply filter
			filterIdx := m.bookmarkCursor - len(m.bookmarks)
			if filterIdx >= 0 && filterIdx < len(m.savedFilters) {
				filter := m.savedFilters[filterIdx]
				m.applySavedFilter(filter)
				m.message = fmt.Sprintf("‚úì Applied filter: %s", filter.name)
				m.phase = "select"
				m.showBookmarks = false
			}
		}

	case "s", "S":
		// Save current selection or filter
		if m.countSelected() > 0 {
			// Save as bookmark
			m.saveCurrentBookmark()
			m.message = fmt.Sprintf("‚úì Saved %d VMs as bookmark", m.countSelected())
		} else if m.searchQuery != "" || m.filterPower != "" || m.filterOS != "" {
			// Save current filter
			m.saveCurrentFilter()
			m.message = "‚úì Saved current filter"
		} else {
			m.message = "Select VMs or apply filters first, then press 'S' to save"
		}

	case "d", "D":
		// Delete the selected bookmark or filter
		if m.bookmarkCursor < len(m.bookmarks) {
			// Delete bookmark
			bookmark := m.bookmarks[m.bookmarkCursor]
			m.bookmarks = append(m.bookmarks[:m.bookmarkCursor], m.bookmarks[m.bookmarkCursor+1:]...)
			m.message = fmt.Sprintf("‚úó Deleted bookmark: %s", bookmark.name)
			if m.bookmarkCursor >= len(m.bookmarks) && m.bookmarkCursor > 0 {
				m.bookmarkCursor--
			}
		} else {
			// Delete filter
			filterIdx := m.bookmarkCursor - len(m.bookmarks)
			if filterIdx >= 0 && filterIdx < len(m.savedFilters) {
				filter := m.savedFilters[filterIdx]
				m.savedFilters = append(m.savedFilters[:filterIdx], m.savedFilters[filterIdx+1:]...)
				m.message = fmt.Sprintf("‚úó Deleted filter: %s", filter.name)
				if m.bookmarkCursor > 0 {
					m.bookmarkCursor--
				}
			}
		}
	}

	return m, nil
}

// applyBookmark applies a saved bookmark by selecting the VMs
func (m *tuiModel) applyBookmark(bookmark vmBookmark) {
	// Clear current selection
	for i := range m.vms {
		m.vms[i].selected = false
	}

	// Select VMs from bookmark
	for _, vmPath := range bookmark.vmPaths {
		for i := range m.vms {
			if m.vms[i].vm.Path == vmPath {
				m.vms[i].selected = true
				break
			}
		}
	}
}

// applySavedFilter applies a saved filter configuration
func (m *tuiModel) applySavedFilter(filter savedFilter) {
	m.filterPower = filter.powerState
	m.filterOS = filter.osFilter
	m.searchQuery = filter.searchQuery
	m.applyFiltersAndSort()
}

// saveCurrentBookmark saves the currently selected VMs as a bookmark
func (m *tuiModel) saveCurrentBookmark() {
	vmPaths := make([]string, 0)
	vmNames := make([]string, 0)

	for _, item := range m.vms {
		if item.selected {
			vmPaths = append(vmPaths, item.vm.Path)
			vmNames = append(vmNames, item.vm.Name)
		}
	}

	if len(vmPaths) == 0 {
		return
	}

	// Generate bookmark name from VM names
	bookmarkName := vmNames[0]
	if len(vmNames) > 1 {
		bookmarkName += fmt.Sprintf(" +%d more", len(vmNames)-1)
	}

	bookmark := vmBookmark{
		name:        bookmarkName,
		description: fmt.Sprintf("Saved on %s", time.Now().Format("Jan 2, 2006 15:04")),
		vmPaths:     vmPaths,
		created:     time.Now(),
		icon:        "üìå",
	}

	m.bookmarks = append(m.bookmarks, bookmark)
}

// saveCurrentFilter saves the current filter configuration
func (m *tuiModel) saveCurrentFilter() {
	filterName := "Custom Filter"
	if m.searchQuery != "" {
		filterName = fmt.Sprintf("Search: %s", m.searchQuery)
	} else if m.filterPower != "" {
		filterName = fmt.Sprintf("Power: %s", m.filterPower)
	} else if m.filterOS != "" {
		filterName = fmt.Sprintf("OS: %s", m.filterOS)
	}

	filter := savedFilter{
		name:        filterName,
		description: fmt.Sprintf("Saved on %s", time.Now().Format("Jan 2, 2006 15:04")),
		powerState:  m.filterPower,
		osFilter:    m.filterOS,
		searchQuery: m.searchQuery,
		created:     time.Now(),
	}

	m.savedFilters = append(m.savedFilters, filter)
}

// initializeSampleBookmarks adds sample bookmarks for demonstration
func (m *tuiModel) initializeSampleBookmarks() {
	m.bookmarks = []vmBookmark{
		{
			name:        "Production Servers",
			description: "All production VMs for export",
			vmPaths:     []string{}, // Would be populated with actual VM paths
			created:     time.Now().Add(-24 * time.Hour),
			icon:        "üè≠",
		},
		{
			name:        "Development VMs",
			description: "Development environment VMs",
			vmPaths:     []string{},
			created:     time.Now().Add(-48 * time.Hour),
			icon:        "üîß",
		},
		{
			name:        "Database Servers",
			description: "All database VMs",
			vmPaths:     []string{},
			created:     time.Now().Add(-72 * time.Hour),
			icon:        "üíæ",
		},
	}
}

// initializeSampleFilters adds sample filters for demonstration
func (m *tuiModel) initializeSampleFilters() {
	m.savedFilters = []savedFilter{
		{
			name:        "Large VMs",
			description: "VMs with >8 CPUs and >16GB RAM",
			minCPU:      8,
			minMemoryGB: 16,
			created:     time.Now().Add(-24 * time.Hour),
		},
		{
			name:        "Linux Production",
			description: "Running Linux VMs",
			powerState:  "poweredOn",
			osFilter:    "Linux",
			created:     time.Now().Add(-48 * time.Hour),
		},
		{
			name:        "Windows Powered Off",
			description: "Stopped Windows VMs",
			powerState:  "poweredOff",
			osFilter:    "Windows",
			created:     time.Now().Add(-72 * time.Hour),
		},
	}
}

// renderMetrics renders the performance metrics dashboard
func (m tuiModel) renderMetrics() string {
	var b strings.Builder

	// Header
	modeText := map[string]string{
		"overview": "OVERVIEW",
		"cpu":      "CPU METRICS",
		"memory":   "MEMORY METRICS",
		"storage":  "STORAGE METRICS",
	}
	header := lipgloss.NewStyle().
		Foreground(deepOrange).
		Bold(true).
		Render(fmt.Sprintf("üìä PERFORMANCE METRICS - %s  (Esc/M: Back | 1-4: Switch Mode)", modeText[m.metricsMode]))
	b.WriteString(header)
	b.WriteString("\n\n")

	// Mode selector
	modeBar := lipgloss.NewStyle().
		Foreground(mutedGray).
		Render("Modes: ")

	modes := []string{"1:Overview", "2:CPU", "3:Memory", "4:Storage"}
	modeMapping := []string{"overview", "cpu", "memory", "storage"}

	for i, modeLabel := range modes {
		if modeMapping[i] == m.metricsMode {
			modeBar += lipgloss.NewStyle().
				Foreground(deepOrange).
				Bold(true).
				Background(lightBg).
				Render(fmt.Sprintf(" [%s] ", modeLabel))
		} else {
			modeBar += lipgloss.NewStyle().
				Foreground(mutedGray).
				Render(fmt.Sprintf("  %s  ", modeLabel))
		}
	}
	b.WriteString(modeBar)
	b.WriteString("\n\n")

	// Render metrics based on mode
	switch m.metricsMode {
	case "overview":
		b.WriteString(m.renderMetricsOverview())
	case "cpu":
		b.WriteString(m.renderMetricsCPU())
	case "memory":
		b.WriteString(m.renderMetricsMemory())
	case "storage":
		b.WriteString(m.renderMetricsStorage())
	}

	// Help footer
	helpText := helpStyleTUI.Render("1-4: Switch metrics mode | R: Refresh | Esc/M: Back to selection")
	b.WriteString("\n")
	b.WriteString(helpText)
	b.WriteString("\n")

	return b.String()
}

// renderMetricsOverview renders the overview metrics
func (m tuiModel) renderMetricsOverview() string {
	var b strings.Builder

	// Calculate aggregate statistics
	totalVMs := len(m.vms)
	poweredOn := 0
	poweredOff := 0
	var totalCPU int32
	var totalMemoryMB int32
	var totalStorageBytes int64

	for _, item := range m.vms {
		if item.vm.PowerState == "poweredOn" {
			poweredOn++
		} else {
			poweredOff++
		}
		totalCPU += item.vm.NumCPU
		totalMemoryMB += item.vm.MemoryMB
		totalStorageBytes += item.vm.Storage
	}

	// Infrastructure overview
	sectionTitle := lipgloss.NewStyle().
		Foreground(tealInfo).
		Bold(true).
		Render("Infrastructure Overview")
	b.WriteString(sectionTitle)
	b.WriteString("\n\n")

	overviewBox := panelStyleTUI.Render(
		fmt.Sprintf(
			"  Total VMs: %s\n"+
				"  Powered On: %s\n"+
				"  Powered Off: %s\n"+
				"  Selected: %s",
			statsStyleTUI.Render(fmt.Sprintf("%d", totalVMs)),
			statsStyleTUI.Render(fmt.Sprintf("%d", poweredOn)),
			statsStyleTUI.Render(fmt.Sprintf("%d", poweredOff)),
			statsStyleTUI.Render(fmt.Sprintf("%d", m.countSelected())),
		),
	)
	b.WriteString(overviewBox)
	b.WriteString("\n\n")

	// Resource allocation
	resourceTitle := lipgloss.NewStyle().
		Foreground(tealInfo).
		Bold(true).
		Render("Resource Allocation")
	b.WriteString(resourceTitle)
	b.WriteString("\n\n")

	resourceBox := panelStyleTUI.Render(
		fmt.Sprintf(
			"  Total vCPUs: %s\n"+
				"  Total Memory: %s\n"+
				"  Total Storage: %s\n"+
				"  Avg CPUs/VM: %s",
			statsStyleTUI.Render(fmt.Sprintf("%d", totalCPU)),
			statsStyleTUI.Render(fmt.Sprintf("%.1f GB", float64(totalMemoryMB)/1024)),
			statsStyleTUI.Render(formatBytes(totalStorageBytes)),
			statsStyleTUI.Render(fmt.Sprintf("%.1f", float64(totalCPU)/float64(max(totalVMs, 1)))),
		),
	)
	b.WriteString(resourceBox)
	b.WriteString("\n\n")

	// Distribution stats
	distTitle := lipgloss.NewStyle().
		Foreground(tealInfo).
		Bold(true).
		Render("OS Distribution")
	b.WriteString(distTitle)
	b.WriteString("\n")

	// Count OS types
	osCount := make(map[string]int)
	for _, item := range m.vms {
		os := item.vm.GuestOS
		if strings.Contains(strings.ToLower(os), "linux") {
			osCount["Linux"]++
		} else if strings.Contains(strings.ToLower(os), "windows") {
			osCount["Windows"]++
		} else {
			osCount["Other"]++
		}
	}

	for os, count := range osCount {
		percentage := float64(count) / float64(max(totalVMs, 1)) * 100
		bar := strings.Repeat("‚ñà", int(percentage/2))
		b.WriteString(fmt.Sprintf("  %s: %s %.1f%% (%d VMs)\n",
			lipgloss.NewStyle().Width(10).Render(os),
			lipgloss.NewStyle().Foreground(tealInfo).Render(bar),
			percentage,
			count,
		))
	}

	return b.String()
}

// renderMetricsCPU renders CPU metrics
func (m tuiModel) renderMetricsCPU() string {
	var b strings.Builder

	sectionTitle := lipgloss.NewStyle().
		Foreground(tealInfo).
		Bold(true).
		Render("CPU Allocation Statistics")
	b.WriteString(sectionTitle)
	b.WriteString("\n\n")

	// CPU distribution
	cpuDist := make(map[int32]int)
	var maxCPU int32
	var minCPU int32 = 9999
	var totalCPU int32

	for _, item := range m.vms {
		cpu := item.vm.NumCPU
		cpuDist[cpu]++
		totalCPU += cpu
		if cpu > maxCPU {
			maxCPU = cpu
		}
		if cpu < minCPU {
			minCPU = cpu
		}
	}

	avgCPU := float64(totalCPU) / float64(max(len(m.vms), 1))

	statsBox := panelStyleTUI.Render(
		fmt.Sprintf(
			"  Total vCPUs: %s\n"+
				"  Average: %s vCPUs/VM\n"+
				"  Maximum: %s vCPUs\n"+
				"  Minimum: %s vCPUs",
			statsStyleTUI.Render(fmt.Sprintf("%d", totalCPU)),
			statsStyleTUI.Render(fmt.Sprintf("%.1f", avgCPU)),
			statsStyleTUI.Render(fmt.Sprintf("%d", maxCPU)),
			statsStyleTUI.Render(fmt.Sprintf("%d", minCPU)),
		),
	)
	b.WriteString(statsBox)
	b.WriteString("\n\n")

	// Distribution chart
	distTitle := lipgloss.NewStyle().
		Foreground(amberYellow).
		Bold(true).
		Render("CPU Distribution")
	b.WriteString(distTitle)
	b.WriteString("\n")

	// Get sorted CPU values
	cpuVals := make([]int32, 0, len(cpuDist))
	for cpu := range cpuDist {
		cpuVals = append(cpuVals, cpu)
	}
	// Simple sort
	for i := 0; i < len(cpuVals); i++ {
		for j := i + 1; j < len(cpuVals); j++ {
			if cpuVals[i] > cpuVals[j] {
				cpuVals[i], cpuVals[j] = cpuVals[j], cpuVals[i]
			}
		}
	}

	for _, cpu := range cpuVals {
		count := cpuDist[cpu]
		percentage := float64(count) / float64(len(m.vms)) * 100
		bar := strings.Repeat("‚ñà", int(percentage))
		b.WriteString(fmt.Sprintf("  %2d vCPUs: %s %.1f%% (%d VMs)\n",
			cpu,
			lipgloss.NewStyle().Foreground(deepOrange).Render(bar),
			percentage,
			count,
		))
	}

	return b.String()
}

// renderMetricsMemory renders memory metrics
func (m tuiModel) renderMetricsMemory() string {
	var b strings.Builder

	sectionTitle := lipgloss.NewStyle().
		Foreground(tealInfo).
		Bold(true).
		Render("Memory Allocation Statistics")
	b.WriteString(sectionTitle)
	b.WriteString("\n\n")

	var totalMemoryMB int32
	var maxMemoryMB int32
	var minMemoryMB int32 = 999999

	for _, item := range m.vms {
		mem := item.vm.MemoryMB
		totalMemoryMB += mem
		if mem > maxMemoryMB {
			maxMemoryMB = mem
		}
		if mem < minMemoryMB {
			minMemoryMB = mem
		}
	}

	avgMemoryMB := float64(totalMemoryMB) / float64(max(len(m.vms), 1))
	totalMemoryGB := float64(totalMemoryMB) / 1024

	statsBox := panelStyleTUI.Render(
		fmt.Sprintf(
			"  Total Memory: %s\n"+
				"  Average: %s/VM\n"+
				"  Maximum: %s\n"+
				"  Minimum: %s",
			statsStyleTUI.Render(fmt.Sprintf("%.1f GB", totalMemoryGB)),
			statsStyleTUI.Render(fmt.Sprintf("%.1f GB", avgMemoryMB/1024)),
			statsStyleTUI.Render(fmt.Sprintf("%.1f GB", float64(maxMemoryMB)/1024)),
			statsStyleTUI.Render(fmt.Sprintf("%.1f GB", float64(minMemoryMB)/1024)),
		),
	)
	b.WriteString(statsBox)
	b.WriteString("\n\n")

	// Memory ranges
	rangeTitle := lipgloss.NewStyle().
		Foreground(amberYellow).
		Bold(true).
		Render("Memory Distribution")
	b.WriteString(rangeTitle)
	b.WriteString("\n")

	// Count VMs in memory ranges
	ranges := map[string]int{
		"< 4 GB":      0,
		"4-8 GB":      0,
		"8-16 GB":     0,
		"16-32 GB":    0,
		"> 32 GB":     0,
	}

	for _, item := range m.vms {
		memGB := float64(item.vm.MemoryMB) / 1024
		if memGB < 4 {
			ranges["< 4 GB"]++
		} else if memGB < 8 {
			ranges["4-8 GB"]++
		} else if memGB < 16 {
			ranges["8-16 GB"]++
		} else if memGB < 32 {
			ranges["16-32 GB"]++
		} else {
			ranges["> 32 GB"]++
		}
	}

	rangeOrder := []string{"< 4 GB", "4-8 GB", "8-16 GB", "16-32 GB", "> 32 GB"}
	for _, rng := range rangeOrder {
		count := ranges[rng]
		if count == 0 {
			continue
		}
		percentage := float64(count) / float64(len(m.vms)) * 100
		bar := strings.Repeat("‚ñà", int(percentage))
		b.WriteString(fmt.Sprintf("  %s: %s %.1f%% (%d VMs)\n",
			lipgloss.NewStyle().Width(12).Render(rng),
			lipgloss.NewStyle().Foreground(tealInfo).Render(bar),
			percentage,
			count,
		))
	}

	return b.String()
}

// renderMetricsStorage renders storage metrics
func (m tuiModel) renderMetricsStorage() string {
	var b strings.Builder

	sectionTitle := lipgloss.NewStyle().
		Foreground(tealInfo).
		Bold(true).
		Render("Storage Allocation Statistics")
	b.WriteString(sectionTitle)
	b.WriteString("\n\n")

	var totalStorageBytes int64
	var maxStorageBytes int64
	var minStorageBytes int64 = 9999999999999

	for _, item := range m.vms {
		storage := item.vm.Storage
		totalStorageBytes += storage
		if storage > maxStorageBytes {
			maxStorageBytes = storage
		}
		if storage < minStorageBytes {
			minStorageBytes = storage
		}
	}

	avgStorageBytes := totalStorageBytes / int64(max(len(m.vms), 1))

	statsBox := panelStyleTUI.Render(
		fmt.Sprintf(
			"  Total Storage: %s\n"+
				"  Average: %s/VM\n"+
				"  Maximum: %s\n"+
				"  Minimum: %s",
			statsStyleTUI.Render(formatBytes(totalStorageBytes)),
			statsStyleTUI.Render(formatBytes(avgStorageBytes)),
			statsStyleTUI.Render(formatBytes(maxStorageBytes)),
			statsStyleTUI.Render(formatBytes(minStorageBytes)),
		),
	)
	b.WriteString(statsBox)
	b.WriteString("\n\n")

	// Storage ranges
	rangeTitle := lipgloss.NewStyle().
		Foreground(amberYellow).
		Bold(true).
		Render("Storage Distribution")
	b.WriteString(rangeTitle)
	b.WriteString("\n")

	// Count VMs in storage ranges
	ranges := map[string]int{
		"< 100 GB":    0,
		"100-500 GB":  0,
		"500 GB-1 TB": 0,
		"1-5 TB":      0,
		"> 5 TB":      0,
	}

	for _, item := range m.vms {
		storageGB := float64(item.vm.Storage) / (1024 * 1024 * 1024)
		if storageGB < 100 {
			ranges["< 100 GB"]++
		} else if storageGB < 500 {
			ranges["100-500 GB"]++
		} else if storageGB < 1024 {
			ranges["500 GB-1 TB"]++
		} else if storageGB < 5120 {
			ranges["1-5 TB"]++
		} else {
			ranges["> 5 TB"]++
		}
	}

	rangeOrder := []string{"< 100 GB", "100-500 GB", "500 GB-1 TB", "1-5 TB", "> 5 TB"}
	for _, rng := range rangeOrder {
		count := ranges[rng]
		if count == 0 {
			continue
		}
		percentage := float64(count) / float64(len(m.vms)) * 100
		bar := strings.Repeat("‚ñà", int(percentage))
		b.WriteString(fmt.Sprintf("  %s: %s %.1f%% (%d VMs)\n",
			lipgloss.NewStyle().Width(14).Render(rng),
			lipgloss.NewStyle().Foreground(amberYellow).Render(bar),
			percentage,
			count,
		))
	}

	return b.String()
}

// handleMetricsKeys handles keyboard input in metrics view
func (m tuiModel) handleMetricsKeys(msg tea.KeyMsg) (tea.Model, tea.Cmd) {
	switch msg.String() {
	case "ctrl+c", "q":
		return m, tea.Quit

	case "escape", "M":
		// Return to select phase
		m.phase = "select"
		m.showMetrics = false
		return m, nil

	case "1":
		m.metricsMode = "overview"
	case "2":
		m.metricsMode = "cpu"
	case "3":
		m.metricsMode = "memory"
	case "4":
		m.metricsMode = "storage"

	case "r", "R":
		// Refresh metrics
		m.metricsRefresh = time.Now()
		m.message = "Metrics refreshed"
	}

	return m, nil
}

// renderFilterBuilder renders the advanced filter builder interface
func (m tuiModel) renderFilterBuilder() string {
	if m.filterBuilder == nil {
		return "Filter builder not initialized"
	}

	fb := m.filterBuilder
	var b strings.Builder

	// Title
	titleStyle := lipgloss.NewStyle().
		Bold(true).
		Foreground(lipgloss.Color("39")).
		Background(lipgloss.Color("235")).
		Padding(0, 2)

	b.WriteString(titleStyle.Render("üîç ADVANCED FILTER BUILDER"))
	b.WriteString("\n\n")

	// Mode indicator
	modeStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("208"))
	switch fb.mode {
	case "build":
		b.WriteString(modeStyle.Render("Mode: Building Filter"))
	case "preview":
		b.WriteString(modeStyle.Render("Mode: Preview Results"))
	case "save":
		b.WriteString(modeStyle.Render("Mode: Save Filter"))
	}
	b.WriteString("\n\n")

	if fb.mode == "build" {
		// Render filter criteria fields
		fields := []struct {
			idx   int
			label string
			value string
			hint  string
		}{
			{0, "Name Pattern", fb.namePattern, "e.g., web-*, *prod*, db-?"},
			{1, "Power State", fb.powerState, "[any/on/off]"},
			{2, "OS Pattern", fb.osPattern, "e.g., Ubuntu*, Windows*"},
			{3, "Min CPU", fmt.Sprintf("%d", fb.minCPU), "Minimum vCPUs (0 = any)"},
			{4, "Max CPU", fmt.Sprintf("%d", fb.maxCPU), "Maximum vCPUs (0 = unlimited)"},
			{5, "Min Memory (GB)", fmt.Sprintf("%.1f", fb.minMemoryGB), "Minimum RAM"},
			{6, "Max Memory (GB)", fmt.Sprintf("%.1f", fb.maxMemoryGB), "Maximum RAM (0 = unlimited)"},
			{7, "Min Storage (GB)", fmt.Sprintf("%.1f", fb.minStorageGB), "Minimum disk space"},
			{8, "Max Storage (GB)", fmt.Sprintf("%.1f", fb.maxStorageGB), "Maximum disk space (0 = unlimited)"},
			{9, "Folder Pattern", fb.folderPattern, "e.g., /Datacenter/*/Production"},
			{10, "Match Mode", fb.matchMode, "[all=AND / any=OR]"},
			{11, "Case Sensitive", fmt.Sprintf("%t", fb.caseSensitive), "[true/false]"},
			{12, "Use Regex", fmt.Sprintf("%t", fb.useRegex), "[true/false]"},
		}

		labelStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("243"))
		valueStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("255"))
		focusedStyle := lipgloss.NewStyle().
			Foreground(lipgloss.Color("39")).
			Bold(true).
			Background(lipgloss.Color("237"))
		hintStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("240")).Italic(true)

		for _, field := range fields {
			prefix := "  "
			if field.idx == fb.focusedField {
				prefix = "‚ñ∂ "
			}

			fieldLine := prefix + labelStyle.Render(fmt.Sprintf("%-20s", field.label+":"))
			if field.idx == fb.focusedField {
				fieldLine += " " + focusedStyle.Render(fmt.Sprintf("%-25s", field.value))
			} else {
				fieldLine += " " + valueStyle.Render(fmt.Sprintf("%-25s", field.value))
			}
			fieldLine += " " + hintStyle.Render(field.hint)
			b.WriteString(fieldLine + "\n")
		}

		// Match preview
		b.WriteString("\n")
		previewStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("46"))
		matchCount := m.filterPreviewCount
		b.WriteString(previewStyle.Render(fmt.Sprintf("üìä Matches: %d VMs", matchCount)))

	} else if fb.mode == "preview" {
		// Show preview results
		b.WriteString(lipgloss.NewStyle().Foreground(lipgloss.Color("46")).Render(
			fmt.Sprintf("Filter matches %d VMs:\n\n", len(fb.previewResults))))

		headerStyle := lipgloss.NewStyle().Bold(true).Foreground(lipgloss.Color("255"))
		b.WriteString(headerStyle.Render(fmt.Sprintf("%-30s %-12s %-6s %-10s %-12s\n",
			"Name", "Power", "CPU", "Memory", "Storage")))
		b.WriteString(strings.Repeat("‚îÄ", 80) + "\n")

		// Show first 15 results
		maxShow := 15
		if len(fb.previewResults) < maxShow {
			maxShow = len(fb.previewResults)
		}

		for i := 0; i < maxShow; i++ {
			vm := fb.previewResults[i]
			powerIcon := "‚óè"
			powerColor := lipgloss.Color("243")
			if vm.PowerState == "poweredOn" {
				powerIcon = "‚óè"
				powerColor = lipgloss.Color("46")
			}

			b.WriteString(fmt.Sprintf("%-30s %s %-10s %4d   %-10s %-12s\n",
				truncateString(vm.Name, 30),
				lipgloss.NewStyle().Foreground(powerColor).Render(powerIcon),
				vm.PowerState,
				vm.NumCPU,
				fmt.Sprintf("%.1f GB", float64(vm.MemoryMB)/1024),
				formatBytes(vm.Storage)))
		}

		if len(fb.previewResults) > maxShow {
			b.WriteString(fmt.Sprintf("\n... and %d more\n", len(fb.previewResults)-maxShow))
		}

	} else if fb.mode == "save" {
		// Save filter form
		b.WriteString(lipgloss.NewStyle().Foreground(lipgloss.Color("226")).Render("Save Filter Configuration\n\n"))

		fields := []struct {
			idx   int
			label string
			value string
		}{
			{0, "Filter Name", fb.filterName},
			{1, "Description", fb.filterDesc},
		}

		labelStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("243"))
		valueStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("255"))
		focusedStyle := lipgloss.NewStyle().
			Foreground(lipgloss.Color("39")).
			Bold(true).
			Background(lipgloss.Color("237"))

		for _, field := range fields {
			prefix := "  "
			if field.idx == fb.focusedField-100 { // Offset to distinguish from build mode
				prefix = "‚ñ∂ "
			}

			fieldLine := prefix + labelStyle.Render(fmt.Sprintf("%-20s", field.label+":"))
			if field.idx == fb.focusedField-100 {
				fieldLine += " " + focusedStyle.Render(field.value)
			} else {
				fieldLine += " " + valueStyle.Render(field.value)
			}
			b.WriteString(fieldLine + "\n")
		}

		b.WriteString("\n")
		b.WriteString(lipgloss.NewStyle().Foreground(lipgloss.Color("243")).Render(
			"Filter will match " + fmt.Sprintf("%d", len(fb.previewResults)) + " VMs"))
	}

	// Help footer
	b.WriteString("\n\n")
	helpStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("240"))

	switch fb.mode {
	case "build":
		b.WriteString(helpStyle.Render("‚Üë‚Üì/k/j: Navigate | Enter: Edit | P: Preview | S: Save | A: Apply | C: Clear | Esc: Cancel"))
	case "preview":
		b.WriteString(helpStyle.Render("Esc/B: Back to builder | A: Apply filter | S: Save"))
	case "save":
		b.WriteString(helpStyle.Render("Enter: Confirm save | Esc: Cancel"))
	}

	return b.String()
}

// handleFilterBuilderKeys handles keyboard input in filter builder mode
func (m tuiModel) handleFilterBuilderKeys(msg tea.KeyMsg) (tea.Model, tea.Cmd) {
	if m.filterBuilder == nil {
		m.phase = "select"
		return m, nil
	}

	fb := m.filterBuilder

	switch msg.String() {
	case "ctrl+c", "q":
		return m, tea.Quit

	case "escape", "esc":
		if fb.mode == "build" {
			// Exit filter builder
			m.phase = "select"
			m.showFilterBuilder = false
			m.filterBuilder = nil
			return m, nil
		} else {
			// Go back to build mode
			fb.mode = "build"
			fb.focusedField = 0
		}

	case "up", "k":
		if fb.mode == "build" {
			if fb.focusedField > 0 {
				fb.focusedField--
			}
		}

	case "down", "j":
		if fb.mode == "build" {
			if fb.focusedField < 12 { // 13 fields (0-12)
				fb.focusedField++
			}
		}

	case "p", "P":
		if fb.mode == "build" {
			// Switch to preview mode
			fb.mode = "preview"
			fb.previewResults = m.applyFilterBuilder(fb)
			m.filterPreviewCount = len(fb.previewResults)
		}

	case "s", "S":
		// Switch to save mode
		fb.mode = "save"
		fb.focusedField = 100 // Reset for save mode fields
		if fb.filterName == "" {
			fb.filterName = "Custom Filter " + time.Now().Format("15:04")
		}

	case "a", "A":
		// Apply filter to main list
		m.filteredVMs = make([]tuiVMItem, 0)
		matches := m.applyFilterBuilder(fb)
		for _, vm := range matches {
			for _, item := range m.vms {
				if item.vm.Path == vm.Path {
					m.filteredVMs = append(m.filteredVMs, item)
					break
				}
			}
		}
		m.cursor = 0
		m.message = fmt.Sprintf("Applied filter: %d VMs match", len(m.filteredVMs))
		m.phase = "select"
		m.showFilterBuilder = false
		return m, nil

	case "c", "C":
		if fb.mode == "build" {
			// Clear all filters
			*fb = filterBuilderState{
				mode:      "build",
				matchMode: "all",
			}
			m.filterPreviewCount = 0
		}

	case "b", "B":
		if fb.mode == "preview" {
			fb.mode = "build"
		}

	case "enter":
		if fb.mode == "save" {
			// Save the filter
			newFilter := savedFilter{
				name:         fb.filterName,
				description:  fb.filterDesc,
				powerState:   fb.powerState,
				osFilter:     fb.osPattern,
				minCPU:       fb.minCPU,
				searchQuery:  fb.namePattern,
				minMemoryGB:  fb.minMemoryGB,
				minStorageGB: fb.minStorageGB,
				created:      time.Now(),
			}
			m.savedFilters = append(m.savedFilters, newFilter)
			m.message = fmt.Sprintf("Filter '%s' saved successfully", fb.filterName)
			m.phase = "select"
			m.showFilterBuilder = false
			return m, nil
		}
		// In build mode, enter could toggle or edit the focused field
		// For simplicity, we'll use specific keys to modify values

	case "0", "1", "2", "3", "4", "5", "6", "7", "8", "9":
		// For numeric fields, could implement inline editing
		// For now, this is a simplified version

	case "t", "T":
		if fb.mode == "build" {
			// Toggle boolean fields
			if fb.focusedField == 11 { // Case Sensitive
				fb.caseSensitive = !fb.caseSensitive
			} else if fb.focusedField == 12 { // Use Regex
				fb.useRegex = !fb.useRegex
			}
		}

	case "m", "M":
		if fb.mode == "build" && fb.focusedField == 10 {
			// Toggle match mode
			if fb.matchMode == "all" {
				fb.matchMode = "any"
			} else {
				fb.matchMode = "all"
			}
		}
	}

	// Update preview count when in build mode
	if fb.mode == "build" {
		matches := m.applyFilterBuilder(fb)
		m.filterPreviewCount = len(matches)
	}

	return m, nil
}

// applyFilterBuilder applies the filter builder criteria to all VMs
func (m tuiModel) applyFilterBuilder(fb *filterBuilderState) []vsphere.VMInfo {
	if fb == nil {
		return nil
	}

	matches := make([]vsphere.VMInfo, 0)

	for _, item := range m.vms {
		vm := item.vm
		matchCount := 0
		totalCriteria := 0

		// Name pattern
		if fb.namePattern != "" {
			totalCriteria++
			if matchesPattern(vm.Name, fb.namePattern, fb.caseSensitive, fb.useRegex) {
				matchCount++
			}
		}

		// Power state
		if fb.powerState != "" {
			totalCriteria++
			expectedState := "poweredOn"
			if fb.powerState == "off" {
				expectedState = "poweredOff"
			}
			if vm.PowerState == expectedState || (fb.powerState == "on" && vm.PowerState == "poweredOn") {
				matchCount++
			}
		}

		// OS pattern
		if fb.osPattern != "" {
			totalCriteria++
			if matchesPattern(vm.GuestOS, fb.osPattern, fb.caseSensitive, fb.useRegex) {
				matchCount++
			}
		}

		// CPU range
		if fb.minCPU > 0 {
			totalCriteria++
			if vm.NumCPU >= fb.minCPU {
				matchCount++
			}
		}
		if fb.maxCPU > 0 {
			totalCriteria++
			if vm.NumCPU <= fb.maxCPU {
				matchCount++
			}
		}

		// Memory range
		memoryGB := float64(vm.MemoryMB) / (1024 * 1024 * 1024)
		if fb.minMemoryGB > 0 {
			totalCriteria++
			if memoryGB >= fb.minMemoryGB {
				matchCount++
			}
		}
		if fb.maxMemoryGB > 0 {
			totalCriteria++
			if memoryGB <= fb.maxMemoryGB {
				matchCount++
			}
		}

		// Storage range
		storageGB := float64(vm.Storage) / (1024 * 1024 * 1024)
		if fb.minStorageGB > 0 {
			totalCriteria++
			if storageGB >= fb.minStorageGB {
				matchCount++
			}
		}
		if fb.maxStorageGB > 0 {
			totalCriteria++
			if storageGB <= fb.maxStorageGB {
				matchCount++
			}
		}

		// Folder pattern
		if fb.folderPattern != "" {
			totalCriteria++
			if matchesPattern(vm.Path, fb.folderPattern, fb.caseSensitive, fb.useRegex) {
				matchCount++
			}
		}

		// Determine if VM matches based on match mode
		if totalCriteria == 0 {
			// No criteria set, match all
			matches = append(matches, vm)
		} else if fb.matchMode == "all" {
			// AND mode: all criteria must match
			if matchCount == totalCriteria {
				matches = append(matches, vm)
			}
		} else {
			// OR mode: at least one criterion must match
			if matchCount > 0 {
				matches = append(matches, vm)
			}
		}
	}

	return matches
}

// matchesPattern checks if a string matches a pattern (wildcard or regex)
func matchesPattern(str, pattern string, caseSensitive, useRegex bool) bool {
	if !caseSensitive {
		str = strings.ToLower(str)
		pattern = strings.ToLower(pattern)
	}

	if useRegex {
		// Use regex matching
		// For safety, we'll use a simple Contains check if regex compilation fails
		matched, _ := filepath.Match(pattern, str)
		return matched || strings.Contains(str, pattern)
	}

	// Wildcard matching
	if strings.Contains(pattern, "*") || strings.Contains(pattern, "?") {
		matched, _ := filepath.Match(pattern, str)
		return matched
	}

	// Simple substring match
	return strings.Contains(str, pattern)
}

// renderSnapshotManager renders the snapshot management interface
func (m tuiModel) renderSnapshotManager() string {
	if m.snapshotManager == nil {
		return "Snapshot manager not initialized"
	}

	sm := m.snapshotManager
	var b strings.Builder

	// Title
	titleStyle := lipgloss.NewStyle().
		Bold(true).
		Foreground(lipgloss.Color("39")).
		Background(lipgloss.Color("235")).
		Padding(0, 2)

	vmName := "Unknown VM"
	if sm.vm != nil {
		vmName = sm.vm.Name
	}
	b.WriteString(titleStyle.Render(fmt.Sprintf("üì∏ SNAPSHOT MANAGER - %s", vmName)))
	b.WriteString("\n\n")

	// Mode indicator
	modeStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("208"))
	switch sm.mode {
	case "list":
		b.WriteString(modeStyle.Render("Mode: Snapshot List"))
	case "create":
		b.WriteString(modeStyle.Render("Mode: Create Snapshot"))
	case "details":
		b.WriteString(modeStyle.Render("Mode: Snapshot Details"))
	case "tree":
		b.WriteString(modeStyle.Render("Mode: Snapshot Tree"))
	}
	b.WriteString("\n\n")

	if sm.mode == "list" {
		// Render snapshot list
		if len(sm.snapshots) == 0 {
			b.WriteString(lipgloss.NewStyle().Foreground(lipgloss.Color("243")).Render(
				"No snapshots found for this VM\n"))
			b.WriteString(lipgloss.NewStyle().Foreground(lipgloss.Color("46")).Render(
				"\nPress 'C' to create a new snapshot"))
		} else {
			// Header
			headerStyle := lipgloss.NewStyle().Bold(true).Foreground(lipgloss.Color("255"))
			b.WriteString(headerStyle.Render(fmt.Sprintf("%-40s %-12s %-20s %s\n",
				"Name", "Size", "Created", "State")))
			b.WriteString(strings.Repeat("‚îÄ", 90) + "\n")

			// List snapshots
			for i, snap := range sm.snapshots {
				prefix := "  "
				if i == sm.cursor {
					prefix = "‚ñ∂ "
				}

				currentMarker := ""
				if snap.isCurrent {
					currentMarker = " [CURRENT]"
				}

				style := lipgloss.NewStyle().Foreground(lipgloss.Color("255"))
				if i == sm.cursor {
					style = lipgloss.NewStyle().
						Foreground(lipgloss.Color("39")).
						Bold(true).
						Background(lipgloss.Color("237"))
				}

				stateIcon := "‚óè"
				stateColor := lipgloss.Color("243")
				if snap.state == "poweredOn" {
					stateColor = lipgloss.Color("46")
				}

				line := fmt.Sprintf("%s%-40s %-12s %-20s %s%s",
					prefix,
					truncateString(snap.name, 40),
					formatBytes(snap.size),
					snap.created.Format("2006-01-02 15:04"),
					lipgloss.NewStyle().Foreground(stateColor).Render(stateIcon)+" "+snap.state,
					currentMarker)

				b.WriteString(style.Render(line) + "\n")
			}

			b.WriteString(fmt.Sprintf("\nTotal: %d snapshots", len(sm.snapshots)))
		}

	} else if sm.mode == "create" {
		// Create snapshot form
		b.WriteString(lipgloss.NewStyle().Foreground(lipgloss.Color("226")).Render("Create New Snapshot\n\n"))

		fields := []struct {
			label string
			value string
		}{
			{"Snapshot Name:", sm.createName},
			{"Description:", sm.createDesc},
			{"Include Memory:", fmt.Sprintf("%t", sm.createMemory)},
			{"Quiesce Filesystem:", fmt.Sprintf("%t", sm.createQuiesce)},
		}

		labelStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("243"))
		valueStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("255"))

		for i, field := range fields {
			prefix := "  "
			if i == sm.cursor {
				prefix = "‚ñ∂ "
			}

			fieldLine := prefix + labelStyle.Render(fmt.Sprintf("%-25s", field.label))
			if i == sm.cursor {
				fieldLine += " " + lipgloss.NewStyle().
					Foreground(lipgloss.Color("39")).
					Bold(true).
					Background(lipgloss.Color("237")).
					Render(field.value)
			} else {
				fieldLine += " " + valueStyle.Render(field.value)
			}
			b.WriteString(fieldLine + "\n")
		}

		b.WriteString("\n")
		hintStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("240")).Italic(true)
		b.WriteString(hintStyle.Render("Memory snapshots capture RAM state (slower, larger)"))
		b.WriteString("\n")
		b.WriteString(hintStyle.Render("Quiescing ensures filesystem consistency"))

	} else if sm.mode == "details" {
		// Show detailed snapshot info
		if sm.selectedSnap == nil {
			b.WriteString("No snapshot selected")
		} else {
			snap := sm.selectedSnap
			detailStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("255"))
			labelStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("243"))

			details := []struct {
				label string
				value string
			}{
				{"Snapshot ID:", snap.id},
				{"Name:", snap.name},
				{"Description:", snap.description},
				{"Created:", snap.created.Format("2006-01-02 15:04:05")},
				{"Size:", formatBytes(snap.size)},
				{"Power State:", snap.state},
				{"Is Current:", fmt.Sprintf("%t", snap.isCurrent)},
				{"Parent:", snap.parent},
				{"Children:", fmt.Sprintf("%d", len(snap.children))},
			}

			for _, detail := range details {
				b.WriteString(labelStyle.Render(fmt.Sprintf("%-20s", detail.label)))
				b.WriteString(" " + detailStyle.Render(detail.value) + "\n")
			}

			// Actions
			b.WriteString("\n")
			actionStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("46"))
			b.WriteString(actionStyle.Render("Available Actions:\n"))
			b.WriteString("  R - Revert to this snapshot\n")
			b.WriteString("  D - Delete this snapshot\n")
			b.WriteString("  Esc - Back to list\n")
		}

	} else if sm.mode == "tree" {
		// Show snapshot tree view
		b.WriteString(lipgloss.NewStyle().Foreground(lipgloss.Color("46")).Render(
			"Snapshot Hierarchy Tree\n\n"))

		if len(sm.treeView) == 0 {
			b.WriteString("No snapshots to display")
		} else {
			for i, node := range sm.treeView {
				prefix := strings.Repeat("  ", node.level)

				// Tree branch characters
				if node.level > 0 {
					if node.isLast {
						prefix += "‚îî‚îÄ "
					} else {
						prefix += "‚îú‚îÄ "
					}
				}

				// Cursor indicator
				cursor := "  "
				if i == sm.treeCursor {
					cursor = "‚ñ∂ "
				}

				style := lipgloss.NewStyle().Foreground(lipgloss.Color("255"))
				if i == sm.treeCursor {
					style = lipgloss.NewStyle().
						Foreground(lipgloss.Color("39")).
						Bold(true)
				}

				currentMarker := ""
				if node.snapshot != nil && node.snapshot.isCurrent {
					currentMarker = " [CURRENT]"
				}

				snapName := "Root"
				if node.snapshot != nil {
					snapName = node.snapshot.name
				}

				line := cursor + prefix + snapName + currentMarker
				b.WriteString(style.Render(line) + "\n")
			}
		}
	}

	// Help footer
	b.WriteString("\n\n")
	helpStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("240"))

	switch sm.mode {
	case "list":
		b.WriteString(helpStyle.Render("‚Üë‚Üì/k/j: Navigate | Enter: Details | C: Create | D: Delete | T: Tree View | R: Revert | Esc: Back"))
	case "create":
		b.WriteString(helpStyle.Render("‚Üë‚Üì/k/j: Navigate | T: Toggle | Enter: Create | Esc: Cancel"))
	case "details":
		b.WriteString(helpStyle.Render("R: Revert | D: Delete | Esc: Back to list"))
	case "tree":
		b.WriteString(helpStyle.Render("‚Üë‚Üì/k/j: Navigate | Enter: Expand/Collapse | L: Switch to list | Esc: Back"))
	}

	return b.String()
}

// handleSnapshotManagerKeys handles keyboard input in snapshot manager mode
func (m tuiModel) handleSnapshotManagerKeys(msg tea.KeyMsg) (tea.Model, tea.Cmd) {
	if m.snapshotManager == nil {
		m.phase = "select"
		return m, nil
	}

	sm := m.snapshotManager

	switch msg.String() {
	case "ctrl+c", "q":
		return m, tea.Quit

	case "escape", "esc":
		if sm.mode == "list" {
			// Exit snapshot manager
			m.phase = "select"
			m.showSnapshotManager = false
			m.snapshotManager = nil
			return m, nil
		} else {
			// Go back to list mode
			sm.mode = "list"
			sm.cursor = 0
		}

	case "up", "k":
		if sm.mode == "list" || sm.mode == "tree" {
			if sm.mode == "list" && sm.cursor > 0 {
				sm.cursor--
			} else if sm.mode == "tree" && sm.treeCursor > 0 {
				sm.treeCursor--
			}
		} else if sm.mode == "create" {
			if sm.cursor > 0 {
				sm.cursor--
			}
		}

	case "down", "j":
		if sm.mode == "list" {
			if sm.cursor < len(sm.snapshots)-1 {
				sm.cursor++
			}
		} else if sm.mode == "tree" {
			if sm.treeCursor < len(sm.treeView)-1 {
				sm.treeCursor++
			}
		} else if sm.mode == "create" {
			if sm.cursor < 3 { // 4 fields (0-3)
				sm.cursor++
			}
		}

	case "enter":
		if sm.mode == "list" {
			// Show details for selected snapshot
			if sm.cursor < len(sm.snapshots) {
				sm.selectedSnap = &sm.snapshots[sm.cursor]
				sm.mode = "details"
			}
		} else if sm.mode == "create" {
			// Create the snapshot (simulated)
			if sm.createName == "" {
				sm.createName = "Snapshot-" + time.Now().Format("20060102-150405")
			}
			m.message = fmt.Sprintf("Creating snapshot '%s'...", sm.createName)

			// Add new snapshot to list (simulated)
			newSnap := vmSnapshot{
				id:          fmt.Sprintf("snap-%d", len(sm.snapshots)+1),
				name:        sm.createName,
				description: sm.createDesc,
				created:     time.Now(),
				size:        sm.vm.Storage / 10, // Estimate 10% of VM size
				state:       sm.vm.PowerState,
				isCurrent:   true,
			}
			sm.snapshots = append(sm.snapshots, newSnap)

			sm.mode = "list"
			sm.cursor = len(sm.snapshots) - 1
			m.message = "Snapshot created successfully"
			return m, nil
		} else if sm.mode == "tree" {
			// Toggle expand/collapse (future enhancement)
			if sm.treeCursor < len(sm.treeView) {
				sm.treeView[sm.treeCursor].expanded = !sm.treeView[sm.treeCursor].expanded
			}
		}

	case "c", "C":
		if sm.mode == "list" {
			// Switch to create mode
			sm.mode = "create"
			sm.cursor = 0
			sm.createName = ""
			sm.createDesc = ""
			sm.createMemory = false
			sm.createQuiesce = true
		}

	case "t", "T":
		if sm.mode == "list" {
			// Switch to tree view
			sm.mode = "tree"
			sm.treeCursor = 0
			sm.buildSnapshotTree()
		} else if sm.mode == "tree" {
			// Switch back to list
			sm.mode = "list"
			sm.cursor = 0
		} else if sm.mode == "create" {
			// Toggle boolean fields
			if sm.cursor == 2 {
				sm.createMemory = !sm.createMemory
			} else if sm.cursor == 3 {
				sm.createQuiesce = !sm.createQuiesce
			}
		}

	case "l", "L":
		if sm.mode == "tree" {
			sm.mode = "list"
			sm.cursor = 0
		}

	case "d", "D":
		if sm.mode == "list" && len(sm.snapshots) > 0 {
			// Delete selected snapshot (simulated)
			if sm.cursor < len(sm.snapshots) {
				deletedName := sm.snapshots[sm.cursor].name
				sm.snapshots = append(sm.snapshots[:sm.cursor], sm.snapshots[sm.cursor+1:]...)
				if sm.cursor > 0 && sm.cursor >= len(sm.snapshots) {
					sm.cursor--
				}
				m.message = fmt.Sprintf("Deleted snapshot '%s'", deletedName)
			}
		} else if sm.mode == "details" && sm.selectedSnap != nil {
			// Delete from details view
			deletedName := sm.selectedSnap.name
			for i, snap := range sm.snapshots {
				if snap.id == sm.selectedSnap.id {
					sm.snapshots = append(sm.snapshots[:i], sm.snapshots[i+1:]...)
					break
				}
			}
			sm.mode = "list"
			sm.cursor = 0
			m.message = fmt.Sprintf("Deleted snapshot '%s'", deletedName)
		}

	case "r", "R":
		if sm.mode == "list" && len(sm.snapshots) > 0 {
			// Revert to selected snapshot (simulated)
			if sm.cursor < len(sm.snapshots) {
				snapName := sm.snapshots[sm.cursor].name
				// Mark as current
				for i := range sm.snapshots {
					sm.snapshots[i].isCurrent = false
				}
				sm.snapshots[sm.cursor].isCurrent = true
				m.message = fmt.Sprintf("Reverted to snapshot '%s'", snapName)
			}
		} else if sm.mode == "details" && sm.selectedSnap != nil {
			// Revert from details view
			for i := range sm.snapshots {
				sm.snapshots[i].isCurrent = false
				if sm.snapshots[i].id == sm.selectedSnap.id {
					sm.snapshots[i].isCurrent = true
				}
			}
			m.message = fmt.Sprintf("Reverted to snapshot '%s'", sm.selectedSnap.name)
			sm.mode = "list"
		}
	}

	return m, nil
}

// buildSnapshotTree builds the tree view of snapshots
func (sm *snapshotManagerState) buildSnapshotTree() {
	sm.treeView = make([]snapshotTreeNode, 0)

	// Simple flat list for now (hierarchical tree could be added later)
	for i := range sm.snapshots {
		node := snapshotTreeNode{
			snapshot: &sm.snapshots[i],
			level:    0,
			isLast:   i == len(sm.snapshots)-1,
			expanded: true,
		}
		sm.treeView = append(sm.treeView, node)
	}
}

// loadSnapshotsForVM loads snapshots for a given VM (simulated)
func (m *tuiModel) loadSnapshotsForVM(vm *vsphere.VMInfo) []vmSnapshot {
	// Simulate loading snapshots
	// In real implementation, this would call vSphere API
	snapshots := []vmSnapshot{
		{
			id:          "snap-1",
			name:        "Before Update",
			description: "Snapshot before system update",
			created:     time.Now().Add(-48 * time.Hour),
			size:        vm.Storage / 10,
			state:       "poweredOff",
			parent:      "",
			children:    []string{"snap-2"},
			isCurrent:   false,
		},
		{
			id:          "snap-2",
			name:        "Production Baseline",
			description: "Clean production configuration",
			created:     time.Now().Add(-24 * time.Hour),
			size:        vm.Storage / 8,
			state:       "poweredOn",
			parent:      "snap-1",
			children:    []string{},
			isCurrent:   true,
		},
	}

	return snapshots
}

// renderResourcePlanner renders the resource allocation planner interface
func (m tuiModel) renderResourcePlanner() string {
	if m.resourcePlanner == nil {
		return "Resource planner not initialized"
	}

	rp := m.resourcePlanner
	var b strings.Builder

	// Title
	titleStyle := lipgloss.NewStyle().
		Bold(true).
		Foreground(lipgloss.Color("39")).
		Background(lipgloss.Color("235")).
		Padding(0, 2)

	b.WriteString(titleStyle.Render("üìä RESOURCE ALLOCATION PLANNER"))
	b.WriteString("\n\n")

	// Mode indicator
	modeStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("208"))
	switch rp.mode {
	case "overview":
		b.WriteString(modeStyle.Render("Mode: Cluster Overview"))
	case "hosts":
		b.WriteString(modeStyle.Render("Mode: Host Resources"))
	case "plan":
		b.WriteString(modeStyle.Render("Mode: Allocation Planning"))
	case "optimize":
		b.WriteString(modeStyle.Render("Mode: Resource Optimization"))
	case "recommendations":
		b.WriteString(modeStyle.Render("Mode: Recommendations"))
	}
	b.WriteString("\n\n")

	if rp.mode == "overview" {
		// Cluster-wide resource overview
		var totalCPU, availableCPU int32
		var totalMemory, availableMemory, totalStorage, availableStorage int64
		totalVMs := 0

		for _, host := range rp.hostCapacity {
			totalCPU += host.totalCPU
			availableCPU += host.availableCPU
			totalMemory += host.totalMemory
			availableMemory += host.availableMemory
			totalStorage += host.totalStorage
			availableStorage += host.availableStorage
			totalVMs += host.vmCount
		}

		headerStyle := lipgloss.NewStyle().Bold(true).Foreground(lipgloss.Color("255"))
		b.WriteString(headerStyle.Render("Cluster Resource Summary\n\n"))

		labelStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("243"))
		valueStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("255"))

		// CPU stats
		cpuUsed := totalCPU - availableCPU
		cpuPercent := float64(0)
		if totalCPU > 0 {
			cpuPercent = float64(cpuUsed) * 100.0 / float64(totalCPU)
		}
		b.WriteString(labelStyle.Render("CPU Resources:        "))
		b.WriteString(valueStyle.Render(fmt.Sprintf("%d / %d cores (%.1f%% used)\n", cpuUsed, totalCPU, cpuPercent)))
		b.WriteString(m.renderResourceBar(cpuPercent, 50))
		b.WriteString("\n\n")

		// Memory stats
		memUsed := totalMemory - availableMemory
		memPercent := float64(0)
		if totalMemory > 0 {
			memPercent = float64(memUsed) * 100.0 / float64(totalMemory)
		}
		b.WriteString(labelStyle.Render("Memory Resources:     "))
		b.WriteString(valueStyle.Render(fmt.Sprintf("%s / %s (%.1f%% used)\n",
			formatBytes(memUsed), formatBytes(totalMemory), memPercent)))
		b.WriteString(m.renderResourceBar(memPercent, 50))
		b.WriteString("\n\n")

		// Storage stats
		storUsed := totalStorage - availableStorage
		storPercent := float64(0)
		if totalStorage > 0 {
			storPercent = float64(storUsed) * 100.0 / float64(totalStorage)
		}
		b.WriteString(labelStyle.Render("Storage Resources:    "))
		b.WriteString(valueStyle.Render(fmt.Sprintf("%s / %s (%.1f%% used)\n",
			formatBytes(storUsed), formatBytes(totalStorage), storPercent)))
		b.WriteString(m.renderResourceBar(storPercent, 50))
		b.WriteString("\n\n")

		// Summary stats
		b.WriteString(headerStyle.Render("Cluster Statistics\n\n"))
		b.WriteString(labelStyle.Render("Total Hosts:          "))
		b.WriteString(valueStyle.Render(fmt.Sprintf("%d\n", len(rp.hostCapacity))))
		b.WriteString(labelStyle.Render("Total VMs:            "))
		b.WriteString(valueStyle.Render(fmt.Sprintf("%d\n", totalVMs)))
		b.WriteString(labelStyle.Render("Average VMs per Host: "))
		avgVMs := 0.0
		if len(rp.hostCapacity) > 0 {
			avgVMs = float64(totalVMs) / float64(len(rp.hostCapacity))
		}
		b.WriteString(valueStyle.Render(fmt.Sprintf("%.1f\n", avgVMs)))

	} else if rp.mode == "hosts" {
		// Host-by-host resource breakdown
		headerStyle := lipgloss.NewStyle().Bold(true).Foreground(lipgloss.Color("255"))
		b.WriteString(headerStyle.Render(fmt.Sprintf("%-25s %-12s %-15s %-15s %-10s %s\n",
			"Host", "VMs", "CPU", "Memory", "Storage", "Status")))
		b.WriteString(strings.Repeat("‚îÄ", 100) + "\n")

		hostList := make([]hostResources, 0)
		for _, host := range rp.hostCapacity {
			hostList = append(hostList, host)
		}

		for i, host := range hostList {
			prefix := "  "
			if i == rp.cursor {
				prefix = "‚ñ∂ "
			}

			cpuUsed := host.totalCPU - host.availableCPU
			cpuPercent := float64(0)
			if host.totalCPU > 0 {
				cpuPercent = float64(cpuUsed) * 100.0 / float64(host.totalCPU)
			}

			memUsed := host.totalMemory - host.availableMemory
			memPercent := float64(0)
			if host.totalMemory > 0 {
				memPercent = float64(memUsed) * 100.0 / float64(host.totalMemory)
			}

			storUsed := host.totalStorage - host.availableStorage
			storPercent := float64(0)
			if host.totalStorage > 0 {
				storPercent = float64(storUsed) * 100.0 / float64(host.totalStorage)
			}

			statusColor := lipgloss.Color("46") // Green for healthy
			if host.status == "overcommitted" {
				statusColor = lipgloss.Color("196") // Red
			} else if host.status == "underutilized" {
				statusColor = lipgloss.Color("226") // Yellow
			}

			style := lipgloss.NewStyle().Foreground(lipgloss.Color("255"))
			if i == rp.cursor {
				style = lipgloss.NewStyle().
					Foreground(lipgloss.Color("39")).
					Bold(true).
					Background(lipgloss.Color("237"))
			}

			line := fmt.Sprintf("%s%-25s %3d        %4d/%-4d (%3.0f%%) %8s/%-8s (%3.0f%%) %6s/%-6s (%3.0f%%) %s",
				prefix,
				truncateString(host.name, 25),
				host.vmCount,
				cpuUsed, host.totalCPU, cpuPercent,
				formatBytes(memUsed)[:8], formatBytes(host.totalMemory)[:8], memPercent,
				formatBytes(storUsed)[:6], formatBytes(host.totalStorage)[:6], storPercent,
				lipgloss.NewStyle().Foreground(statusColor).Render(host.status))

			b.WriteString(style.Render(line) + "\n")
		}

	} else if rp.mode == "plan" {
		// Allocation planning
		selectedVMs := m.getSelectedVMs()
		b.WriteString(lipgloss.NewStyle().Foreground(lipgloss.Color("226")).Render(
			fmt.Sprintf("Planning allocation for %d selected VMs\n\n", len(selectedVMs))))

		if len(selectedVMs) > 0 {
			var totalCPU int32
			var totalMemory, totalStorage int64

			for _, vmItem := range selectedVMs {
				totalCPU += vmItem.vm.NumCPU
				totalMemory += int64(vmItem.vm.MemoryMB)
				totalStorage += vmItem.vm.Storage
			}

			labelStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("243"))
			valueStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("255"))

			b.WriteString(labelStyle.Render("Total CPU Required:    "))
			b.WriteString(valueStyle.Render(fmt.Sprintf("%d cores\n", totalCPU)))
			b.WriteString(labelStyle.Render("Total Memory Required: "))
			b.WriteString(valueStyle.Render(fmt.Sprintf("%s\n", formatBytes(totalMemory))))
			b.WriteString(labelStyle.Render("Total Storage Required:"))
			b.WriteString(valueStyle.Render(fmt.Sprintf("%s\n\n", formatBytes(totalStorage))))

			// Find suitable hosts
			b.WriteString(lipgloss.NewStyle().Bold(true).Foreground(lipgloss.Color("46")).Render(
				"Suitable Hosts:\n\n"))

			suitableCount := 0
			for _, host := range rp.hostCapacity {
				if host.availableCPU >= totalCPU &&
					host.availableMemory >= totalMemory &&
					host.availableStorage >= totalStorage {
					suitableCount++
					b.WriteString(fmt.Sprintf("  ‚úì %s - CPU: %d available, Mem: %s, Storage: %s\n",
						host.name,
						host.availableCPU,
						formatBytes(host.availableMemory),
						formatBytes(host.availableStorage)))
				}
			}

			if suitableCount == 0 {
				b.WriteString(lipgloss.NewStyle().Foreground(lipgloss.Color("196")).Render(
					"  ‚ö† No single host can accommodate all selected VMs\n"))
				b.WriteString(lipgloss.NewStyle().Foreground(lipgloss.Color("243")).Render(
					"  Consider distributing VMs across multiple hosts\n"))
			}
		} else {
			b.WriteString("No VMs selected. Select VMs in the main view first.")
		}

	} else if rp.mode == "optimize" {
		// Optimization recommendations
		b.WriteString(lipgloss.NewStyle().Foreground(lipgloss.Color("226")).Render(
			fmt.Sprintf("Optimization Goal: %s\n\n", rp.optimizationGoal)))

		headerStyle := lipgloss.NewStyle().Bold(true).Foreground(lipgloss.Color("46"))
		b.WriteString(headerStyle.Render("Optimization Recommendations:\n\n"))

		recommendations := m.generateOptimizationRecommendations(rp)
		for i, rec := range recommendations {
			prefix := "  "
			if i == rp.cursor {
				prefix = "‚ñ∂ "
			}

			style := lipgloss.NewStyle().Foreground(lipgloss.Color("255"))
			if i == rp.cursor {
				style = lipgloss.NewStyle().
					Foreground(lipgloss.Color("39")).
					Bold(true)
			}

			b.WriteString(style.Render(prefix + rec + "\n"))
		}

	} else if rp.mode == "recommendations" {
		// General recommendations
		headerStyle := lipgloss.NewStyle().Bold(true).Foreground(lipgloss.Color("46"))
		b.WriteString(headerStyle.Render("Resource Management Recommendations\n\n"))

		recommendations := []string{
			"Consider consolidating VMs on underutilized hosts to reduce power consumption",
			"Balance CPU-heavy and memory-heavy workloads across hosts",
			"Implement DRS (Distributed Resource Scheduler) for automatic load balancing",
			"Review storage allocation to avoid fragmentation",
			"Set up resource pools for different workload types",
			"Monitor peak usage times and plan capacity accordingly",
			"Use snapshots judiciously to manage storage consumption",
			"Implement resource reservations for critical VMs",
		}

		for _, rec := range recommendations {
			b.WriteString(fmt.Sprintf("  ‚Ä¢ %s\n", rec))
		}
	}

	// Help footer
	b.WriteString("\n\n")
	helpStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("240"))

	switch rp.mode {
	case "overview":
		b.WriteString(helpStyle.Render("1: Overview | 2: Hosts | 3: Plan | 4: Optimize | 5: Recommendations | Esc: Back"))
	case "hosts":
		b.WriteString(helpStyle.Render("‚Üë‚Üì/k/j: Navigate | 1-5: Switch mode | Esc: Back"))
	case "plan":
		b.WriteString(helpStyle.Render("1-5: Switch mode | Esc: Back"))
	case "optimize":
		b.WriteString(helpStyle.Render("‚Üë‚Üì/k/j: Navigate | G: Change goal | 1-5: Switch mode | Esc: Back"))
	case "recommendations":
		b.WriteString(helpStyle.Render("1-5: Switch mode | Esc: Back"))
	}

	return b.String()
}

// renderResourceBar renders a visual bar graph for resource utilization
func (m tuiModel) renderResourceBar(percent float64, width int) string {
	filled := int(percent * float64(width) / 100.0)
	if filled > width {
		filled = width
	}

	var color lipgloss.Color
	if percent < 60 {
		color = lipgloss.Color("46") // Green
	} else if percent < 80 {
		color = lipgloss.Color("226") // Yellow
	} else {
		color = lipgloss.Color("196") // Red
	}

	bar := strings.Repeat("‚ñà", filled) + strings.Repeat("‚ñë", width-filled)
	return lipgloss.NewStyle().Foreground(color).Render(bar) + fmt.Sprintf(" %.1f%%", percent)
}

// handleResourcePlannerKeys handles keyboard input in resource planner mode
func (m tuiModel) handleResourcePlannerKeys(msg tea.KeyMsg) (tea.Model, tea.Cmd) {
	if m.resourcePlanner == nil {
		m.phase = "select"
		return m, nil
	}

	rp := m.resourcePlanner

	switch msg.String() {
	case "ctrl+c", "q":
		return m, tea.Quit

	case "escape", "esc":
		// Exit resource planner
		m.phase = "select"
		m.showResourcePlanner = false
		m.resourcePlanner = nil
		return m, nil

	case "1":
		rp.mode = "overview"
		rp.cursor = 0

	case "2":
		rp.mode = "hosts"
		rp.cursor = 0

	case "3":
		rp.mode = "plan"
		rp.cursor = 0

	case "4":
		rp.mode = "optimize"
		rp.cursor = 0

	case "5":
		rp.mode = "recommendations"
		rp.cursor = 0

	case "up", "k":
		if rp.mode == "hosts" || rp.mode == "optimize" {
			if rp.cursor > 0 {
				rp.cursor--
			}
		}

	case "down", "j":
		if rp.mode == "hosts" {
			if rp.cursor < len(rp.hostCapacity)-1 {
				rp.cursor++
			}
		} else if rp.mode == "optimize" {
			recommendations := m.generateOptimizationRecommendations(rp)
			if rp.cursor < len(recommendations)-1 {
				rp.cursor++
			}
		}

	case "g", "G":
		if rp.mode == "optimize" {
			// Cycle through optimization goals
			goals := []string{"balanced", "cpu", "memory", "storage", "cost"}
			for i, goal := range goals {
				if goal == rp.optimizationGoal {
					rp.optimizationGoal = goals[(i+1)%len(goals)]
					break
				}
			}
		}
	}

	return m, nil
}

// generateOptimizationRecommendations generates optimization recommendations
func (m tuiModel) generateOptimizationRecommendations(rp *resourcePlannerState) []string {
	recommendations := make([]string, 0)

	switch rp.optimizationGoal {
	case "balanced":
		recommendations = append(recommendations,
			"Distribute VMs evenly across all hosts to balance resource usage",
			"Move CPU-intensive VMs to hosts with lower CPU utilization",
			"Consolidate memory-light VMs to free up memory on busy hosts",
			"Use anti-affinity rules to separate critical VMs across hosts")

	case "cpu":
		recommendations = append(recommendations,
			"Migrate VMs from CPU-constrained hosts to hosts with available cores",
			"Consider CPU resource pools for different priority levels",
			"Enable CPU hot-add for scalability without downtime",
			"Review and adjust CPU reservations and limits")

	case "memory":
		recommendations = append(recommendations,
			"Consolidate VMs on memory-rich hosts",
			"Enable memory ballooning for flexible allocation",
			"Consider memory compression for better utilization",
			"Review memory reservations and reduce where possible")

	case "storage":
		recommendations = append(recommendations,
			"Move large VMs to hosts with more storage capacity",
			"Clean up old snapshots to reclaim space",
			"Use thin provisioning to reduce storage footprint",
			"Consider storage vMotion to balance datastore usage")

	case "cost":
		recommendations = append(recommendations,
			"Consolidate VMs to minimize number of active hosts",
			"Power off or suspend development/test VMs when not in use",
			"Right-size VMs to match actual resource usage",
			"Use resource pools to enforce budget constraints")
	}

	return recommendations
}

// initializeResourcePlanner initializes the resource planner with simulated data
func (m *tuiModel) initializeResourcePlanner() *resourcePlannerState {
	// Simulate host capacity data
	hostCapacity := make(map[string]hostResources)

	// Calculate aggregate VM stats
	var totalVMCPU int32
	var totalVMMemory, totalVMStorage int64
	for _, vmItem := range m.vms {
		totalVMCPU += vmItem.vm.NumCPU
		totalVMMemory += int64(vmItem.vm.MemoryMB)
		totalVMStorage += vmItem.vm.Storage
	}

	// Simulate 3 hosts with varying capacity
	vmCount := len(m.vms)
	vmPerHost := vmCount / 3

	hostCapacity["esxi-host-01"] = hostResources{
		name:             "esxi-host-01",
		totalCPU:         64,
		totalMemory:      256 * 1024 * 1024 * 1024, // 256 GB
		totalStorage:     4 * 1024 * 1024 * 1024 * 1024, // 4 TB
		availableCPU:     32,
		availableMemory:  128 * 1024 * 1024 * 1024,
		availableStorage: 2 * 1024 * 1024 * 1024 * 1024,
		vmCount:          vmPerHost,
		status:           "healthy",
	}

	hostCapacity["esxi-host-02"] = hostResources{
		name:             "esxi-host-02",
		totalCPU:         64,
		totalMemory:      256 * 1024 * 1024 * 1024,
		totalStorage:     4 * 1024 * 1024 * 1024 * 1024,
		availableCPU:     8,
		availableMemory:  32 * 1024 * 1024 * 1024,
		availableStorage: 500 * 1024 * 1024 * 1024,
		vmCount:          vmPerHost + 5,
		status:           "overcommitted",
	}

	hostCapacity["esxi-host-03"] = hostResources{
		name:             "esxi-host-03",
		totalCPU:         64,
		totalMemory:      256 * 1024 * 1024 * 1024,
		totalStorage:     4 * 1024 * 1024 * 1024 * 1024,
		availableCPU:     48,
		availableMemory:  192 * 1024 * 1024 * 1024,
		availableStorage: 3 * 1024 * 1024 * 1024 * 1024,
		vmCount:          vmPerHost - 5,
		status:           "underutilized",
	}

	return &resourcePlannerState{
		mode:             "overview",
		scenarios:        make([]resourceAllocation, 0),
		selectedScenario: 0,
		cursor:           0,
		hostCapacity:     hostCapacity,
		optimizationGoal: "balanced",
	}
}

// renderMigrationWizard renders the migration wizard interface
func (m tuiModel) renderMigrationWizard() string {
	if m.migrationWizard == nil {
		return "Migration wizard not initialized"
	}

	mw := m.migrationWizard
	var b strings.Builder

	// Title
	titleStyle := lipgloss.NewStyle().
		Bold(true).
		Foreground(lipgloss.Color("39")).
		Background(lipgloss.Color("235")).
		Padding(0, 2)

	b.WriteString(titleStyle.Render("üöÄ MIGRATION WIZARD"))
	b.WriteString("\n\n")

	// Progress bar showing wizard steps
	steps := []migrationStep{
		{0, "Select VMs", "Choose VMs to migrate", mw.step > 0},
		{1, "Source Config", "Configure source platform", mw.step > 1},
		{2, "Target Config", "Configure target platform", mw.step > 2},
		{3, "Migration Mode", "Choose migration strategy", mw.step > 3},
		{4, "Validation", "Pre-migration checks", mw.step > 4},
		{5, "Schedule", "Set migration time", mw.step > 5},
		{6, "Review", "Final review and confirm", mw.step > 6},
	}

	// Render step progress bar
	for i, step := range steps {
		var style lipgloss.Style
		if i < mw.step {
			style = lipgloss.NewStyle().Foreground(lipgloss.Color("46")) // Green for completed
		} else if i == mw.step {
			style = lipgloss.NewStyle().
				Foreground(lipgloss.Color("39")).
				Bold(true) // Blue for current
		} else {
			style = lipgloss.NewStyle().Foreground(lipgloss.Color("243")) // Gray for pending
		}

		indicator := "‚óã"
		if step.completed {
			indicator = "‚óè"
		}

		b.WriteString(style.Render(fmt.Sprintf("%s Step %d: %s", indicator, i+1, step.title)))
		if i < len(steps)-1 {
			b.WriteString(style.Render(" ‚Üí "))
		}
	}
	b.WriteString("\n\n")

	// Current step details
	currentStep := steps[mw.step]
	stepStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("226"))
	b.WriteString(stepStyle.Render(fmt.Sprintf("Step %d: %s\n", mw.step+1, currentStep.title)))
	b.WriteString(lipgloss.NewStyle().Foreground(lipgloss.Color("243")).Render(currentStep.description + "\n\n"))

	// Step-specific content
	switch mw.step {
	case 0: // Select VMs
		b.WriteString(lipgloss.NewStyle().Foreground(lipgloss.Color("255")).Render(
			fmt.Sprintf("Selected VMs: %d\n\n", len(mw.vms))))

		if len(mw.vms) > 0 {
			headerStyle := lipgloss.NewStyle().Bold(true).Foreground(lipgloss.Color("255"))
			b.WriteString(headerStyle.Render(fmt.Sprintf("%-30s %-10s %-12s %s\n",
				"VM Name", "CPU", "Memory", "Storage")))
			b.WriteString(strings.Repeat("‚îÄ", 70) + "\n")

			for _, vm := range mw.vms {
				b.WriteString(fmt.Sprintf("  %-30s %4d cores %-12s %s\n",
					truncateString(vm.Name, 30),
					vm.NumCPU,
					formatBytes(int64(vm.MemoryMB) * 1024 * 1024),
					formatBytes(vm.Storage)))
			}

			// Calculate totals
			var totalCPU int32
			var totalMemory, totalStorage int64
			for _, vm := range mw.vms {
				totalCPU += vm.NumCPU
				totalMemory += int64(vm.MemoryMB)
				totalStorage += vm.Storage
			}

			b.WriteString(strings.Repeat("‚îÄ", 70) + "\n")
			b.WriteString(fmt.Sprintf("  %-30s %4d cores %-12s %s\n",
				"TOTAL",
				totalCPU,
				formatBytes(totalMemory),
				formatBytes(totalStorage)))
		} else {
			b.WriteString(lipgloss.NewStyle().Foreground(lipgloss.Color("196")).Render(
				"No VMs selected. Go back and select VMs in the main view.\n"))
		}

	case 1: // Source Config
		b.WriteString(lipgloss.NewStyle().Bold(true).Foreground(lipgloss.Color("255")).Render("Source Platform Configuration\n\n"))

		platforms := []string{"vSphere", "AWS", "Azure", "Hyper-V"}
		for i, platform := range platforms {
			prefix := "  "
			platformLower := strings.ToLower(platform)
			if platformLower == mw.sourceType || (platform == "vSphere" && mw.sourceType == "vsphere") {
				prefix = "‚ñ∂ "
			}

			style := lipgloss.NewStyle().Foreground(lipgloss.Color("255"))
			if platformLower == mw.sourceType || (platform == "vSphere" && mw.sourceType == "vsphere") {
				style = lipgloss.NewStyle().
					Foreground(lipgloss.Color("39")).
					Bold(true).
					Background(lipgloss.Color("237"))
			}

			b.WriteString(style.Render(fmt.Sprintf("%s[%d] %s\n", prefix, i+1, platform)))
		}

		if mw.sourceType != "" {
			b.WriteString("\n")
			b.WriteString(lipgloss.NewStyle().Foreground(lipgloss.Color("46")).Render(
				fmt.Sprintf("‚úì Source platform: %s\n", mw.sourceType)))
		}

	case 2: // Target Config
		b.WriteString(lipgloss.NewStyle().Bold(true).Foreground(lipgloss.Color("255")).Render("Target Platform Configuration\n\n"))

		platforms := []string{"vSphere", "AWS", "Azure", "KVM/Local", "OVF Export"}
		for i, platform := range platforms {
			prefix := "  "
			platformLower := strings.ToLower(platform)
			selected := platformLower == mw.targetType ||
				(platform == "KVM/Local" && mw.targetType == "kvm") ||
				(platform == "OVF Export" && mw.targetType == "local")

			if selected {
				prefix = "‚ñ∂ "
			}

			style := lipgloss.NewStyle().Foreground(lipgloss.Color("255"))
			if selected {
				style = lipgloss.NewStyle().
					Foreground(lipgloss.Color("39")).
					Bold(true).
					Background(lipgloss.Color("237"))
			}

			b.WriteString(style.Render(fmt.Sprintf("%s[%d] %s\n", prefix, i+1, platform)))
		}

		if mw.targetType != "" {
			b.WriteString("\n")
			b.WriteString(lipgloss.NewStyle().Foreground(lipgloss.Color("46")).Render(
				fmt.Sprintf("‚úì Target platform: %s\n", mw.targetType)))
		}

	case 3: // Migration Mode
		b.WriteString(lipgloss.NewStyle().Bold(true).Foreground(lipgloss.Color("255")).Render("Migration Strategy\n\n"))

		modes := []struct {
			name string
			desc string
		}{
			{"Cold Migration", "Power off VMs, migrate, then power on (safest, requires downtime)"},
			{"Hot Migration", "Migrate running VMs with minimal downtime (complex, requires compatible platforms)"},
			{"Snapshot Export", "Export VM snapshots for backup or clone purposes"},
		}

		for i, mode := range modes {
			prefix := "  "
			modeLower := strings.ToLower(strings.Fields(mode.name)[0])
			if modeLower == mw.migrationMode {
				prefix = "‚ñ∂ "
			}

			style := lipgloss.NewStyle().Foreground(lipgloss.Color("255"))
			if modeLower == mw.migrationMode {
				style = lipgloss.NewStyle().
					Foreground(lipgloss.Color("39")).
					Bold(true)
			}

			b.WriteString(style.Render(fmt.Sprintf("%s[%d] %s\n", prefix, i+1, mode.name)))
			b.WriteString(lipgloss.NewStyle().Foreground(lipgloss.Color("243")).Render(
				fmt.Sprintf("    %s\n", mode.desc)))
			b.WriteString("\n")
		}

	case 4: // Validation
		b.WriteString(lipgloss.NewStyle().Bold(true).Foreground(lipgloss.Color("255")).Render("Pre-Migration Validation\n\n"))

		if len(mw.validationChecks) > 0 {
			for _, check := range mw.validationChecks {
				var icon, color string
				switch check.status {
				case "passed":
					icon = "‚úì"
					color = "46"
				case "failed":
					icon = "‚úó"
					color = "196"
				case "warning":
					icon = "‚ö†"
					color = "226"
				case "running":
					icon = "‚ü≥"
					color = "39"
				default:
					icon = "‚óã"
					color = "243"
				}

				style := lipgloss.NewStyle().Foreground(lipgloss.Color(color))
				b.WriteString(style.Render(fmt.Sprintf("%s %s: %s\n", icon, check.name, check.message)))
			}

			// Summary
			passed := 0
			failed := 0
			warnings := 0
			for _, check := range mw.validationChecks {
				switch check.status {
				case "passed":
					passed++
				case "failed":
					failed++
				case "warning":
					warnings++
				}
			}

			b.WriteString("\n")
			b.WriteString(fmt.Sprintf("Summary: %d passed, %d warnings, %d failed\n",
				passed, warnings, failed))

			if failed > 0 {
				b.WriteString("\n")
				b.WriteString(lipgloss.NewStyle().Foreground(lipgloss.Color("196")).Render(
					"‚ö† Migration cannot proceed due to failed checks\n"))
			} else if warnings > 0 {
				b.WriteString("\n")
				b.WriteString(lipgloss.NewStyle().Foreground(lipgloss.Color("226")).Render(
					"‚ö† Migration can proceed but has warnings\n"))
			} else if passed == len(mw.validationChecks) {
				b.WriteString("\n")
				b.WriteString(lipgloss.NewStyle().Foreground(lipgloss.Color("46")).Render(
					"‚úì All validation checks passed - ready to migrate\n"))
				mw.readyToMigrate = true
			}
		} else {
			b.WriteString("Running validation checks...\n")
		}

	case 5: // Schedule
		b.WriteString(lipgloss.NewStyle().Bold(true).Foreground(lipgloss.Color("255")).Render("Migration Scheduling\n\n"))

		options := []struct {
			name string
			desc string
		}{
			{"Migrate Now", "Start migration immediately"},
			{"Schedule for Later", "Set a specific date and time"},
		}

		for i, option := range options {
			prefix := "  "
			if (i == 0 && !mw.useSchedule) || (i == 1 && mw.useSchedule) {
				prefix = "‚ñ∂ "
			}

			style := lipgloss.NewStyle().Foreground(lipgloss.Color("255"))
			if (i == 0 && !mw.useSchedule) || (i == 1 && mw.useSchedule) {
				style = lipgloss.NewStyle().
					Foreground(lipgloss.Color("39")).
					Bold(true)
			}

			b.WriteString(style.Render(fmt.Sprintf("%s[%d] %s\n", prefix, i+1, option.name)))
			b.WriteString(lipgloss.NewStyle().Foreground(lipgloss.Color("243")).Render(
				fmt.Sprintf("    %s\n", option.desc)))
		}

		if mw.useSchedule {
			b.WriteString("\n")
			b.WriteString(lipgloss.NewStyle().Foreground(lipgloss.Color("255")).Render(
				fmt.Sprintf("Scheduled time: %s\n", mw.scheduledTime.Format("2006-01-02 15:04 MST"))))
		}

		// Estimates
		b.WriteString("\n")
		b.WriteString(lipgloss.NewStyle().Bold(true).Foreground(lipgloss.Color("255")).Render("Migration Estimates\n\n"))
		b.WriteString(fmt.Sprintf("Estimated duration: %s\n", mw.estimatedTime))
		b.WriteString(fmt.Sprintf("Total data size: %s\n", formatBytes(mw.estimatedSize)))
		b.WriteString(fmt.Sprintf("Network bandwidth: %s/s\n", formatBytes(mw.networkBandwidth)))

	case 6: // Review
		b.WriteString(lipgloss.NewStyle().Bold(true).Foreground(lipgloss.Color("255")).Render("Migration Summary\n\n"))

		labelStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("243"))
		valueStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("255"))

		b.WriteString(labelStyle.Render("VMs to migrate:     "))
		b.WriteString(valueStyle.Render(fmt.Sprintf("%d\n", len(mw.vms))))

		b.WriteString(labelStyle.Render("Source platform:    "))
		b.WriteString(valueStyle.Render(fmt.Sprintf("%s\n", mw.sourceType)))

		b.WriteString(labelStyle.Render("Target platform:    "))
		b.WriteString(valueStyle.Render(fmt.Sprintf("%s\n", mw.targetType)))

		b.WriteString(labelStyle.Render("Migration mode:     "))
		b.WriteString(valueStyle.Render(fmt.Sprintf("%s\n", mw.migrationMode)))

		b.WriteString(labelStyle.Render("Total size:         "))
		b.WriteString(valueStyle.Render(fmt.Sprintf("%s\n", formatBytes(mw.estimatedSize))))

		b.WriteString(labelStyle.Render("Estimated duration: "))
		b.WriteString(valueStyle.Render(fmt.Sprintf("%s\n", mw.estimatedTime)))

		if mw.useSchedule {
			b.WriteString(labelStyle.Render("Scheduled time:     "))
			b.WriteString(valueStyle.Render(fmt.Sprintf("%s\n", mw.scheduledTime.Format("2006-01-02 15:04 MST"))))
		} else {
			b.WriteString(labelStyle.Render("Start time:         "))
			b.WriteString(valueStyle.Render("Immediately\n"))
		}

		b.WriteString("\n")
		if mw.readyToMigrate {
			b.WriteString(lipgloss.NewStyle().Foreground(lipgloss.Color("46")).Render(
				"‚úì Ready to proceed with migration\n"))
			b.WriteString(lipgloss.NewStyle().Foreground(lipgloss.Color("243")).Render(
				"Press Enter to start migration or B to go back\n"))
		} else {
			b.WriteString(lipgloss.NewStyle().Foreground(lipgloss.Color("196")).Render(
				"‚ö† Cannot proceed - validation checks failed\n"))
		}
	}

	// Help footer
	b.WriteString("\n\n")
	helpStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("240"))

	if mw.step == 6 && mw.readyToMigrate {
		b.WriteString(helpStyle.Render("Enter: Start Migration | B: Back | Esc: Cancel"))
	} else if mw.step == 0 {
		b.WriteString(helpStyle.Render("N: Next (if VMs selected) | Esc: Cancel"))
	} else {
		b.WriteString(helpStyle.Render("N: Next | B: Back | Esc: Cancel"))
	}

	return b.String()
}

// handleMigrationWizardKeys handles keyboard input in migration wizard mode
func (m tuiModel) handleMigrationWizardKeys(msg tea.KeyMsg) (tea.Model, tea.Cmd) {
	if m.migrationWizard == nil {
		m.phase = "select"
		return m, nil
	}

	mw := m.migrationWizard

	switch msg.String() {
	case "ctrl+c", "q":
		return m, tea.Quit

	case "escape", "esc":
		// Exit wizard
		m.phase = "select"
		m.showMigrationWizard = false
		m.migrationWizard = nil
		return m, nil

	case "n", "N":
		// Next step
		if mw.step == 0 && len(mw.vms) == 0 {
			m.message = "Please select VMs first"
			return m, nil
		}
		if mw.step < 6 {
			mw.step++
			// Auto-run validation when entering validation step
			if mw.step == 4 {
				mw.validationChecks = m.runMigrationValidation(mw)
			}
			// Calculate estimates when entering schedule step
			if mw.step == 5 {
				mw.estimatedSize = m.calculateMigrationSize(mw)
				mw.estimatedTime = m.calculateMigrationDuration(mw)
				mw.networkBandwidth = 100 * 1024 * 1024 // 100 MB/s default
			}
		}

	case "b", "B":
		// Back step
		if mw.step > 0 {
			mw.step--
		}

	case "1", "2", "3", "4", "5":
		num := int(msg.String()[0] - '0')
		switch mw.step {
		case 1: // Source platform selection
			platforms := []string{"vsphere", "aws", "azure", "hyperv"}
			if num > 0 && num <= len(platforms) {
				mw.sourceType = platforms[num-1]
			}

		case 2: // Target platform selection
			platforms := []string{"vsphere", "aws", "azure", "kvm", "local"}
			if num > 0 && num <= len(platforms) {
				mw.targetType = platforms[num-1]
			}

		case 3: // Migration mode selection
			modes := []string{"cold", "hot", "snapshot"}
			if num > 0 && num <= len(modes) {
				mw.migrationMode = modes[num-1]
			}

		case 5: // Schedule selection
			if num == 1 {
				mw.useSchedule = false
			} else if num == 2 {
				mw.useSchedule = true
				mw.scheduledTime = time.Now().Add(24 * time.Hour)
			}
		}

	case "enter":
		if mw.step == 6 && mw.readyToMigrate {
			// Start migration (would integrate with actual export/migration logic)
			m.message = "Migration started! Check export queue for progress."
			m.phase = "select"
			m.showMigrationWizard = false
			return m, nil
		}
	}

	return m, nil
}

// runMigrationValidation runs pre-migration validation checks
func (m tuiModel) runMigrationValidation(mw *migrationWizardState) []migrationCheck {
	checks := make([]migrationCheck, 0)

	// Check 1: VM selection
	if len(mw.vms) > 0 {
		checks = append(checks, migrationCheck{
			name:     "VM Selection",
			status:   "passed",
			message:  fmt.Sprintf("%d VMs selected", len(mw.vms)),
			critical: true,
		})
	} else {
		checks = append(checks, migrationCheck{
			name:     "VM Selection",
			status:   "failed",
			message:  "No VMs selected",
			critical: true,
		})
	}

	// Check 2: Platform compatibility
	if mw.sourceType != "" && mw.targetType != "" {
		if mw.sourceType == mw.targetType {
			checks = append(checks, migrationCheck{
				name:     "Platform Compatibility",
				status:   "warning",
				message:  "Source and target are the same platform",
				critical: false,
			})
		} else {
			checks = append(checks, migrationCheck{
				name:     "Platform Compatibility",
				status:   "passed",
				message:  fmt.Sprintf("%s to %s migration is supported", mw.sourceType, mw.targetType),
				critical: true,
			})
		}
	} else {
		checks = append(checks, migrationCheck{
			name:     "Platform Compatibility",
			status:   "failed",
			message:  "Source or target platform not configured",
			critical: true,
		})
	}

	// Check 3: Migration mode
	if mw.migrationMode != "" {
		checks = append(checks, migrationCheck{
			name:     "Migration Mode",
			status:   "passed",
			message:  fmt.Sprintf("Using %s migration", mw.migrationMode),
			critical: true,
		})
	} else {
		checks = append(checks, migrationCheck{
			name:     "Migration Mode",
			status:   "failed",
			message:  "Migration mode not selected",
			critical: true,
		})
	}

	// Check 4: Storage capacity (simulated)
	checks = append(checks, migrationCheck{
		name:     "Target Storage Capacity",
		status:   "passed",
		message:  "Sufficient storage available on target",
		critical: true,
	})

	// Check 5: Network connectivity (simulated)
	checks = append(checks, migrationCheck{
		name:     "Network Connectivity",
		status:   "passed",
		message:  "Source and target are reachable",
		critical: true,
	})

	// Check 6: Permissions (simulated)
	checks = append(checks, migrationCheck{
		name:     "Permissions",
		status:   "passed",
		message:  "Sufficient permissions on source and target",
		critical: true,
	})

	return checks
}

// calculateMigrationSize calculates total size for migration
func (m tuiModel) calculateMigrationSize(mw *migrationWizardState) int64 {
	var totalSize int64
	for _, vm := range mw.vms {
		totalSize += vm.Storage
	}
	return totalSize
}

// calculateMigrationDuration estimates migration duration
func (m tuiModel) calculateMigrationDuration(mw *migrationWizardState) time.Duration {
	// Estimate based on size and network speed
	// Assume 100 MB/s network bandwidth
	bandwidth := float64(100 * 1024 * 1024) // bytes per second
	totalBytes := float64(mw.estimatedSize)
	seconds := totalBytes / bandwidth

	// Add overhead for VM operations
	overhead := 300.0 // 5 minutes per VM
	seconds += float64(len(mw.vms)) * overhead

	return time.Duration(seconds) * time.Second
}

// initializeMigrationWizard initializes the wizard with selected VMs
func (m *tuiModel) initializeMigrationWizard() *migrationWizardState {
	selectedVMs := m.getSelectedVMs()
	vms := make([]vsphere.VMInfo, 0)
	for _, item := range selectedVMs {
		vms = append(vms, item.vm)
	}

	return &migrationWizardState{
		step:             0,
		vms:              vms,
		sourceType:       "vsphere", // Default to current type
		targetType:       "",
		sourceDetails:    make(map[string]string),
		targetDetails:    make(map[string]string),
		migrationMode:    "",
		validationChecks: make([]migrationCheck, 0),
		warnings:         make([]string, 0),
		readyToMigrate:   false,
		useSchedule:      false,
	}
}

// handleTreeKeys handles keyboard input in tree view
func (m tuiModel) handleTreeKeys(msg tea.KeyMsg) (tea.Model, tea.Cmd) {
	switch msg.String() {
	case "ctrl+c", "q":
		return m, tea.Quit

	case "]":
		m.viewMode = "list"
		m.phase = "select"
		return m, nil

	case "up", "k":
		if m.treeCursor > 0 {
			m.treeCursor--
		}

	case "down", "j":
		if m.treeCursor < len(m.treeItems)-1 {
			m.treeCursor++
		}

	case "enter":
		m.toggleFolderAtCursor()

	case " ":
		if m.treeCursor < len(m.treeItems) {
			if vmItem, ok := m.treeItems[m.treeCursor].(tuiVMItem); ok {
				for i := range m.vms {
					if m.vms[i].vm.Path == vmItem.vm.Path {
						m.vms[i].selected = !m.vms[i].selected
						m.buildFolderTree()
						break
					}
				}
			} else {
				m.toggleFolderAtCursor()
			}
		}

	case "esc", "b":
		m.viewMode = "list"
		m.phase = "select"
		return m, nil
	}

	return m, nil
}

// handlePreviewKeys handles keyboard input in export preview mode
func (m tuiModel) handlePreviewKeys(msg tea.KeyMsg) (tea.Model, tea.Cmd) {
	switch msg.String() {
	case "ctrl+c", "q":
		return m, tea.Quit

	case "escape", "p", "P", "b":
		// Return to confirm phase
		m.phase = "confirm"
		m.showPreview = false
		return m, nil

	case "up", "k":
		if m.previewCursor > 0 {
			m.previewCursor--
		}

	case "down", "j":
		if m.previewCursor < len(m.exportPreviews)-1 {
			m.previewCursor++
		}

	case "enter", "y":
		// Return to confirm and proceed
		m.phase = "confirm"
		m.showPreview = false
		return m, nil
	}

	return m, nil
}

// generateExportPreviews creates export preview data for all selected VMs
func (m tuiModel) generateExportPreviews() []exportPreview {
	previews := make([]exportPreview, 0)
	selectedVMs := m.getSelectedVMs()

	for _, vmItem := range selectedVMs {
		vm := vmItem.vm

		// Calculate estimated values
		// Estimate number of disks based on storage size (most VMs have 1-2 disks)
		estimatedDisks := 1
		if vm.Storage > 500*1024*1024*1024 { // > 500GB probably has multiple disks
			estimatedDisks = 2
		}

		preview := exportPreview{
			vmName:    vm.Name,
			totalSize: vm.Storage,
			diskCount: estimatedDisks,
			fileBreakdown: make(map[string]int64),
			files:     make([]previewFile, 0),
		}

		// Estimate file breakdown
		// VMDKs are typically the largest files
		vmdkSize := vm.Storage
		ovfSize := int64(1024 * 100) // ~100KB for OVF descriptor
		mfSize := int64(1024)         // ~1KB for manifest

		preview.fileBreakdown["vmdk"] = vmdkSize
		preview.fileBreakdown["ovf"] = ovfSize
		preview.fileBreakdown["mf"] = mfSize

		// Generate file list (estimate disk files based on storage)
		diskSize := vm.Storage / int64(estimatedDisks)
		for i := 0; i < estimatedDisks; i++ {
			preview.files = append(preview.files, previewFile{
				name:     fmt.Sprintf("%s-disk%d.vmdk", sanitizeForPath(vm.Name), i+1),
				fileType: "vmdk",
				size:     diskSize,
			})
		}
		preview.files = append(preview.files, previewFile{
			name:     fmt.Sprintf("%s.ovf", sanitizeForPath(vm.Name)),
			fileType: "ovf",
			size:     ovfSize,
		})
		preview.files = append(preview.files, previewFile{
			name:     fmt.Sprintf("%s.mf", sanitizeForPath(vm.Name)),
			fileType: "mf",
			size:     mfSize,
		})

		// Estimate duration (assume 50 MB/s average transfer speed)
		averageSpeedMBps := float64(50)
		totalSizeMB := float64(vm.Storage) / (1024 * 1024)
		estimatedSeconds := totalSizeMB / averageSpeedMBps
		preview.estimatedDuration = time.Duration(estimatedSeconds) * time.Second

		// Check disk space availability
		var stat syscall.Statfs_t
		outputPath := m.outputDir
		if outputPath == "" {
			outputPath = "./exports"
		}

		// Create directory if it doesn't exist
		os.MkdirAll(outputPath, 0755)

		err := syscall.Statfs(outputPath, &stat)
		if err == nil {
			preview.diskSpaceAvail = int64(stat.Bavail) * int64(stat.Bsize)
		}

		// Calculate disk space needed (with 10% overhead)
		preview.diskSpaceNeeded = vm.Storage + (vm.Storage / 10)

		previews = append(previews, preview)
	}

	return previews
}
